<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EEE4464 IoT Dashboard</title>
    <link rel="stylesheet" href="https://static.integrations.cloudflare.com/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f5f7fa; display: flex; flex-direction: column; min-height: 100vh; }
        header { padding: 10px 20px; background: #0e838f; color: white; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin: 0; font-weight: 700; }
        nav { display: flex; border-bottom: 2px solid #ddd; background: white; }
        nav button {
            flex: 1; padding: 15px; border: none; background: #eee; cursor: pointer; font-weight: 600;
            transition: background-color 0.3s ease;
        }
        nav button.active, nav button:hover {
            background: #0e838f; color: white; box-shadow: 0 4px 10px rgba(14,131,143,.5);
        }
        main { padding: 20px; }
        .tab-content { display: none; animation: fadeIn 0.5s ease forwards; }
        .tab-content.active { display: block; }
        @keyframes fadeIn {
            from {opacity:0; transform: translateY(20px);}
            to {opacity:1; transform: translateY(0);}
        }

        /* Widget layout */
        #widgetContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .widget {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1);
            position: relative;
            transition: transform 0.2s ease;
        }
        .widget:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(14,131,143,0.4);
        }
        .widget .closeBtn {
            position: absolute;
            top: 8px; right: 8px;
            background: #e74c3c;
            border: none;
            border-radius: 50%;
            width: 22px; height: 22px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        .widget .closeBtn:hover {
            opacity: 1;
        }

        /* buttons */
        .btn-group button {
            padding: 8px 15px;
            margin: 0 3px 10px 0;
            border: none;
            background: #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .btn-group button.active, .btn-group button:hover {
            background: #0e838f;
            color: white;
        }

        /* check box */
        select {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        #sensorDataChart {
            width: 100% !important;
            max-width: 800px;
            height: auto !important;
            aspect-ratio: 2/1;
            display: block;
            margin: 0 auto;
        }
        @media (max-width: 600px) {
            main {
                padding: 5px;
            }
            #sensorDataChart {
                max-width: 100vw;
                height: auto !important;
            }
        }

        /* Login Form Styles */
        #loginSection, #registrationSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            padding: 20px;
        }
        .login-container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 360px;
            text-align: center;
        }
        .login-container h2 {
            color: #0e838f;
            margin-bottom: 20px;
        }
        .login-container input[type="text"],
        .login-container input[type="password"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
        }
        .login-container button {
            width: 100%;
            padding: 12px;
            background: #0e838f;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        .login-container button:hover {
            background: #0c707a;
        }
        #loginError, #registrationError {
            color: red;
            margin-top: 10px;
            font-size: 0.9em;
        }
        #logoutButton {
            padding: 8px 15px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }
        #logoutButton:hover {
            background-color: #c0392b;
        }
        .form-switch-link {
            display: block;
            margin-top: 15px;
            color: #0e838f;
            text-decoration: none;
            font-size: 0.9em;
        }
        .form-switch-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<div id="loginSection" style="display:none;">
    <div class="login-container">
        <h2>Dashboard Login</h2>
        <form id="loginForm">
            <input type="text" id="username" placeholder="Username" required />
            <input type="password" id="password" placeholder="Password" required />
            <button type="submit">Login</button>
            <p id="loginError" style="display:none;"></p>
        </form>
        <a href="#" id="switchToRegister" class="form-switch-link">Don't have an account? Register</a>
    </div>
</div>

<div id="registrationSection" style="display:none;">
    <div class="login-container">
        <h2>Create Account</h2>
        <form id="registrationForm">
            <input type="text" id="regUsername" placeholder="Username" required />
            <input type="password" id="regPassword" placeholder="Password" required />
            <input type="password" id="regConfirmPassword" placeholder="Confirm Password" required />
            <button type="submit">Register</button>
            <p id="registrationError" style="display:none;"></p>
        </form>
        <a href="#" id="switchToLogin" class="form-switch-link">Already have an account? Login</a>
    </div>
</div>

<div id="dashboardSection" style="display:none;">
    <header>
        <h1>ðŸŒŸ EEE4464 IoT Dashboard</h1>
        <button id="logoutButton">Logout</button>
    </header>

    <nav>
        <button class="tabBtn active" data-tab="dashboard">Dashboard</button>
        <button class="tabBtn" data-tab="widgets">Widgets</button>
        <button class="tabBtn" data-tab="settings">Settings</button>
        <button class="tabBtn" data-tab="test">Test</button>
    </nav>

    <main>
        <!-- Dashboard Tab -->
        <section id="dashboard" class="tab-content active">
            <div style="margin:10px 0;">
                <label><input type="checkbox" id="autoRefreshCheckbox" /> Auto Refresh</label>
                <input type="number" id="autoRefreshInterval" value="1" min="1" style="width:60px;" /> seconds
            </div>
            <div>
                <label>Select Device:</label><br />
                <select id="deviceSelect"><option>Loading...</option></select>
            </div>
            <div>
                <label>Select Sensors (multiple):</label><br />
                <select id="sensorSelect" multiple size="5"></select>
            </div>
            <div class="btn-group" id="timeRangeButtons">
                <button data-range="hour" class="active">Hour</button>
                <button data-range="day">Day</button>
                <button data-range="week">Week</button>
                <button data-range="month">Month</button>
                <button data-range="year">Year</button>
            </div>
            <div>
                <label>Select Chart Type:</label><br />
                <select id="chartTypeSelect">
                    <option value="line" selected>Line</option>
                    <option value="bar">Bar</option>
                    <option value="pie">Pie</option>
                    <option value="doughnut">Doughnut</option>
                    <option value="radar">Radar</option>
                </select>
            </div>
            <canvas id="sensorDataChart" width="800" height="400" style="max-width: 800px; height: 400px;"></canvas>
        </section>

        <!-- Widgets Tab -->
        <section id="widgets" class="tab-content">
            <button id="addWidgetBtn">Add Status Widget</button>
            <div id="widgetContainer"></div>
        </section>

        <!-- Settings Tab -->
        <section id="settings" class="tab-content">
            <h2>User Settings</h2>
            <p>Current settings are saved in browser <code>localStorage</code> and will not sync across devices.</p>
            <label>Default Time Range:</label>
            <select id="defaultTimeRangeSelect">
                <option value="hour">Hour</option>
                <option value="day">Day</option>
                <option value="week">Week</option>
                <option value="month">Month</option>
                <option value="year">Year</option>
            </select>
            <br/>
            <label>Default Chart Type:</label>
            <select id="defaultChartTypeSelect">
                <option value="line">Line</option>
                <option value="bar">Bar</option>
                <option value="pie">Pie</option>
                <option value="doughnut">Doughnut</option>
                <option value="radar">Radar</option>
            </select>
            <br/><br/>
            <button id="saveSettingsBtn">Save Settings</button>
        </section>
        <!-- Test Tab -->
        <section id="test" class="tab-content">
            <h2>Test Add Data</h2>
            <div style="margin-bottom:10px;">
                <label>Test Devices:</label>
                <div id="testDeviceList"></div>
            </div>
            <div style="margin-bottom:10px;">
                <label>Test Sensors:</label>
                <div id="testSensorList"></div>
            </div>
            <button id="btnAddDevice">Add Device</button>
            <button id="btnAddSensor">Add Sensor (add device first)</button>
            <button id="btnAddControl">Add Control (add sensor first)</button>
            <button id="btnAddSensorData">Add Sensor Data (add sensor first)</button>
            <button id="btnAddAll">Add All Test Data</button>
            <div style="margin-top:10px;">
                <button id="btnTestDelete">Test Delete</button>
                <span id="lastDeviceInfo" style="margin-left:10px;color:#0e838f;font-weight:bold;"></span>
            </div>
        </section>
    </main>
</div>
<script>

    // chart
    let autoRefreshTimer = null;
    let chartDataCache = []; // all sensor data cache
    let chartLastTimestamp = 0;

    // local storage variables
    let lastDeviceId = localStorage.getItem('lastDeviceId') || null;
    let lastControlId = localStorage.getItem('lastControlId') || null;
    let lastSensorId = localStorage.getItem('lastSensorId') || null;
    let lastSensorDataId = localStorage.getItem('lastSensorDataId') || null;

    // --- TAB ---
    const tabs = document.querySelectorAll('.tabBtn');
    const contents = document.querySelectorAll('.tab-content');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            contents.forEach(c => c.classList.remove('active'));
            document.getElementById(tab.dataset.tab).classList.add('active');

            // Show lastDeviceId beside testDelete button when Test tab is active
            if (tab.dataset.tab === 'test') {
                loadTestDeviceList();
            }
        });
    });

    // --- variables ---
    const deviceSelect = document.getElementById('deviceSelect');
    const sensorSelect = document.getElementById('sensorSelect');
    const timeRangeButtons = document.getElementById('timeRangeButtons');
    const chartTypeSelect = document.getElementById('chartTypeSelect');
    const chartCtx = document.getElementById('sensorDataChart').getContext('2d');
    const widgetContainer = document.getElementById('widgetContainer');
    const addWidgetBtn = document.getElementById('addWidgetBtn');
    const defaultTimeRangeSelect = document.getElementById('defaultTimeRangeSelect');
    const defaultChartTypeSelect = document.getElementById('defaultChartTypeSelect');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
    const autoRefreshIntervalInput = document.getElementById('autoRefreshInterval');

    let currentChart = null;
    let renderPending = false;
    let lastDatasets = null;
    let updating = false;
    // remember each line's color
    let lineColors = {};

    let selectedDeviceId = null;
    let selectedSensorIds = [];
    let selectedTimeRange = 'hour';
    let selectedChartType = 'line';
    let widgets = [];

    // User session data
    let currentUser = null;

    function getLineColor(label, idx) {
        if (!lineColors[label]) {
            const baseColors = [
                '#0e838f', '#8a2be2', '#ff7f50', '#ffdc34', '#0ecb81', '#c74e4e', '#bc7af9',
                '#f08a5d', '#f9ed69', '#3ec1d3', '#ffb6b9', '#283c63'
            ];
            lineColors[label] = baseColors[idx % baseColors.length];
        }
        return lineColors[label];
    }

    // init dataset
    const datasets = chartDataCache.map((d, i) => ({
        label: `${d.field} (Sensor:${d.sensorId})`,
        data: d.points,
        borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
        backgroundColor: 'transparent',
        fill: false,
        tension: 0.2,
        pointRadius: 2
    }));
    function startAutoRefresh() {
        if (autoRefreshTimer) clearInterval(autoRefreshTimer);
        if (!autoRefreshCheckbox.checked) return;
        autoRefreshTimer = setInterval(() => {
            fetchNewSensorData();
        }, Number(autoRefreshIntervalInput.value) * 1000);
    }

    // --- init ---
    async function initDashboard() {
        loadSettings();
        await loadDevices(); // This will now use user-specific devices
        await loadAndRenderSensorData();
        setupEventListeners(); // Original event listeners
        startAutoRefresh();
        setInterval(checkNewMessages, 3000);
    }

    // --- Login and Session Management ---
    async function checkLoginState() {
        const token = localStorage.getItem('sessionToken');
        const userDataString = localStorage.getItem('userData');

        if (token && userDataString) {
            currentUser = JSON.parse(userDataString);
            document.getElementById('loginSection').style.display = 'none';
            document.getElementById('registrationSection').style.display = 'none';
            document.getElementById('dashboardSection').style.display = 'block';
            await initDashboard();
        } else {
            showLoginForm(); // Default to login form
            document.getElementById('dashboardSection').style.display = 'none';
            currentUser = null;
        }
    }

    function showLoginForm() {
        document.getElementById('loginSection').style.display = 'flex';
        document.getElementById('registrationSection').style.display = 'none';
    }

    function showRegistrationForm() {
        document.getElementById('loginSection').style.display = 'none';
        document.getElementById('registrationSection').style.display = 'flex';
    }


    document.addEventListener('DOMContentLoaded', () => {
        checkLoginState();

        const loginForm = document.getElementById('loginForm');
        const registrationForm = document.getElementById('registrationForm');
        const switchToRegisterLink = document.getElementById('switchToRegister');
        const switchToLoginLink = document.getElementById('switchToLogin');

        if (switchToRegisterLink) {
            switchToRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                showRegistrationForm();
            });
        }

        if (switchToLoginLink) {
            switchToLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                showLoginForm();
            });
        }


        if (loginForm) {
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const loginError = document.getElementById('loginError');
                loginError.style.display = 'none';

                try {
                    const response = await fetch('/api/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            localStorage.setItem('sessionToken', data.token);
                            localStorage.setItem('userData', JSON.stringify({ username: data.username, devices: data.devices }));
                            await checkLoginState();
                        } else {
                            loginError.textContent = data.message || 'Login failed.';
                            loginError.style.display = 'block';
                        }
                    } else {
                        const errorData = await response.json();
                        loginError.textContent = errorData.message || `Error: ${response.status}`;
                        loginError.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Login request failed:', error);
                    loginError.textContent = 'Login request failed. Check console.';
                    loginError.style.display = 'block';
                }
            });
        }
        
        if (registrationForm) {
            registrationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('regUsername').value;
                const password = document.getElementById('regPassword').value;
                const confirmPassword = document.getElementById('regConfirmPassword').value;
                const registrationError = document.getElementById('registrationError');
                registrationError.style.display = 'none';

                if (password !== confirmPassword) {
                    registrationError.textContent = 'Passwords do not match.';
                    registrationError.style.display = 'block';
                    return;
                }

                // Basic password policy (example: at least 6 characters)
                if (password.length < 6) {
                    registrationError.textContent = 'Password must be at least 6 characters long.';
                    registrationError.style.display = 'block';
                    return;
                }
                // Basic username policy (example: at least 3 characters)
                if (username.length < 3) {
                    registrationError.textContent = 'Username must be at least 3 characters long.';
                    registrationError.style.display = 'block';
                    return;
                }


                try {
                    const response = await fetch('/api/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        alert('Registration successful! Please login.'); // Or show a success message
                        showLoginForm(); // Switch to login form
                        document.getElementById('registrationForm').reset(); // Reset registration form
                    } else {
                        registrationError.textContent = data.message || 'Registration failed.';
                        registrationError.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Registration request failed:', error);
                    registrationError.textContent = 'Registration request failed. Check console.';
                    registrationError.style.display = 'block';
                }
            });
        }

        const logoutButton = document.getElementById('logoutButton');
        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                localStorage.removeItem('sessionToken');
                localStorage.removeItem('userData');
                // Clear sensitive cached data if any
                chartDataCache = [];
                chartLastTimestamp = 0;
                selectedDeviceId = null;
                selectedSensorIds = [];
                if (currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
                // Reset UI elements that might hold old data
                deviceSelect.innerHTML = '<option>Loading...</option>';
                sensorSelect.innerHTML = '';

                checkLoginState();
            });
        }
    });

    // --- load devices ---
    async function loadDevices() {
        const userDataString = localStorage.getItem('userData');
        if (!userDataString) {
            console.error("User data not found for loading devices.");
            deviceSelect.innerHTML = '<option value="">--Login Required--</option>';
            return;
        }
        const userData = JSON.parse(userDataString);
        const allowedDeviceIds = userData.devices; // Expected: array of device_ids

        if (!allowedDeviceIds || allowedDeviceIds.length === 0) {
            deviceSelect.innerHTML = '<option value="">--No Devices Assigned--</option>';
            selectedDeviceId = null; // Ensure selectedDeviceId is cleared
            await loadSensors(null); // Clear sensors
            await loadAndRenderSensorData(); // Clear chart
            return;
        }

        const deviceIdsQueryParam = allowedDeviceIds.map(id => encodeURIComponent(id)).join(',');
        // Fetch only the devices assigned to the user
        const res = await fetch(`/api/device?device_ids=${deviceIdsQueryParam}&limit=${allowedDeviceIds.length}`);
        if (!res.ok) {
            console.error("Failed to load user devices:", await res.text());
            deviceSelect.innerHTML = '<option value="">--Error Loading Devices--</option>';
            return;
        }
        const userDevices = await res.json();

        // @ts-ignore
        deviceSelect.innerHTML = '<option value="">--Please Select Device--</option>' + userDevices.map(function(d) {
            return '<option value="' + d.device_id + '">' + d.device_name +'-'+d.device_type +'-'+d.device_id +'</option>';
        }).join('');
        
        if (userDevices.length > 0) {
            let lastSelectedDeviceId = localStorage.getItem('iot-dashboard-deviceId');
            // Ensure the last selected device is in the allowed list
            const isValidLastDevice = lastSelectedDeviceId && userDevices.some(d => d.device_id.toString() === lastSelectedDeviceId);

            if (isValidLastDevice) {
                deviceSelect.value = lastSelectedDeviceId;
                selectedDeviceId = lastSelectedDeviceId;
            } else {
                deviceSelect.selectedIndex = 0; // Or prompt to select
                selectedDeviceId = null;
                localStorage.removeItem('iot-dashboard-deviceId'); // Clear invalid stored ID
            }
        } else {
            deviceSelect.selectedIndex = 0;
            selectedDeviceId = null;
            localStorage.removeItem('iot-dashboard-deviceId');
        }
        // Trigger change to load sensors for the selected device (if any)
        if (selectedDeviceId) {
             deviceSelect.dispatchEvent(new Event('change', {bubbles: true}));
        } else {
            await loadSensors(null);
            await loadAndRenderSensorData();
        }
    }

    // --- loading sensors ---
    async function loadSensors(deviceId) {
        if (!deviceId) {
            sensorSelect.innerHTML = '';
            return;
        }
        const res = await fetch(`/api/sensors?device_id=${deviceId}&limit=100`);
        const sensors = await res.json();
        sensorSelect.innerHTML = sensors.length ? sensors.map(function(s) {
            return '<option value="' + s.sensor_id + '">' + s.sensor_name + ' (' + (s.sensor_type || 'unknown') + '-' + s.sensor_id + ')</option>';
        }).join('') : '<option>No sensor</option>';
        if (sensorSelect.children.length > 0) {
            const sensorIds = localStorage.getItem('iot-dashboard-sensorId');
            if (sensorIds) {
                setTimeout(() => {
                    const ids = sensorIds.split(',').map(id => id.trim());
                    Array.from(sensorSelect.options).forEach(opt => {
                        opt.selected = ids.includes(opt.value);
                    })
                    sensorSelect.dispatchEvent(new Event('change', {bubbles: true}));
                },0);
            } else {
                sensorSelect.selectedIndex = -1;
                selectedSensorIds = [];
            }
        } else {
            selectedSensorIds = [];
        }
    }

    // --- load and render trending data ---
    async function loadAndRenderSensorData() {
        if (updating) return;
        updating = true;
        if (!selectedSensorIds.length) {
            renderChart([]);
            chartDataCache = [];
            chartLastTimestamp = 0;
            updating = false;
            return;
        }
        const now = Math.floor(Date.now() / 1000);
        let start;
        switch(selectedTimeRange) {
            case 'hour': start = now - 3600; break;
            case 'day': start = now - 86400; break;
            case 'week': start = now - 86400*7; break;
            case 'month': start = now - 86400*30; break;
            case 'year': start = now - 86400*365; break;
            default: start = now - 3600;
        }

        chartDataCache = [];
        chartLastTimestamp = 0;

        await Promise.all(selectedSensorIds.map(async (sensorId) => {
            const resp = await fetch(`/api/sensor_data?sensor_id=${sensorId}&start=${start}&end=${now}&limit=1000`);
            const data = await resp.json();
            if (!data.length) return;
            const allFields = Object.keys(JSON.parse(data[0].data));
            allFields.forEach(field => {
                const points = data.map(d => ({
                    x: d.timestamp * 1000,
                    y: parseFloat(JSON.parse(d.data)[field])
                })).reverse();
                chartDataCache.push({
                    sensorId,
                    field,
                    points
                });
            });
            chartLastTimestamp = Math.max(chartLastTimestamp, ...data.map(d => d.timestamp * 1000));
        }));

        const datasets = chartDataCache.map((d,i) => ({
            label: `${d.field} (Sensor:${d.sensorId})`,
            data: d.points,
            borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
            backgroundColor: 'transparent',
            fill: false,
            tension: 0.2,
            pointRadius: 2
        }));

        renderChart(datasets);
        updating = false;
    }

    async function fetchNewSensorData() {
        if (!selectedSensorIds.length || !chartLastTimestamp) return;
        const now = Math.floor(Date.now() / 1000);
        let hasUpdate = false;
        await Promise.all(chartDataCache.map(async (d) => {
            const resp = await fetch(`/api/sensor_data?sensor_id=${d.sensorId}&start=${Math.floor(chartLastTimestamp/1000)+1}&end=${now}&limit=100`);
            const data = await resp.json();
            if (!data.length) return;
            const newPoints = [];
            data.forEach(row => {
                const val = JSON.parse(row.data)[d.field];
                if (val !== undefined) {
                    newPoints.push({
                        x: row.timestamp * 1000,
                        y: parseFloat(val)
                    });
                }
            });
            if (newPoints.length) {
                d.points = d.points.concat(newPoints);
                hasUpdate = true;
            }
        }));

        if (hasUpdate) {
            chartLastTimestamp = Math.max(...chartDataCache.map(d => d.points.length ? d.points[d.points.length-1].x : 0));
            const datasets = chartDataCache.map((d,i) => ({
                label:`${d.field} (Sensor:${d.sensorId})`,
                data: d.points,
                borderColor:  getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2,
                pointRadius: 2
            }));
            renderChart(datasets);
        }
    }

    function renderChart(datasets) {
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
        const timeUnitMap = {
            hour: 'minute',
            day: 'hour',
            week: 'day',
            month: 'day',
            year: 'month'
        };

        let fitLines = [];
        datasets.forEach((ds, i) => {
            if (ds.data.length > 1) {
                const {k, b} = linearFit(ds.data);
                const x0 = ds.data[0].x;
                const x1 = ds.data[ds.data.length-1].x;
                const fitData = [
                    {x: x0, y: k*0 + b},
                    {x: x1, y: k*(ds.data.length-1) + b}
                ];
                fitLines.push({
                    label: `${ds.label} fit`,
                    data: [
                        {x: x0, y: k*0 + b},
                        {x: x1, y: k*(ds.data.length-1) + b}
                    ],
                    borderColor: ds.borderColor,
                    borderDash: [6, 4],
                    borderWidth: 2,
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0,
                    pointRadius: 0,
                    showLine: true,
                    order: 99,
                    fitFormula: `y = ${k.toFixed(2)}x + ${b.toFixed(2)}`,
                    _fitColor: ds.borderColor
                });
            }
        });

        let allDatasets = [...datasets];
        fitLines.forEach(fit => {
            allDatasets.push({
                label: fit.label,
                data: fit.data,
                borderColor: fit.borderColor,
                borderDash: fit.borderDash,
                borderWidth: fit.borderWidth,
                backgroundColor: fit.backgroundColor,
                fill: fit.fill,
                tension: fit.tension,
                pointRadius: fit.pointRadius,
                showLine: fit.showLine,
                order: fit.order,
                fitFormula: fit.fitFormula,
                _fitColor: fit._fitColor
            });
        });

        let chartType = selectedChartType;
        if (chartType === 'pie' || chartType === 'doughnut') {
            const first = datasets[0];
            if (!first) return;
            currentChart = new Chart(chartCtx, {
                type: chartType,
                data: {
                    labels: first.data.map(p => new Date(p.x).toLocaleString()),
                    datasets: [{
                        label: first.label,
                        data: first.data.map(p => p.y),
                        backgroundColor: pieColors(first.data.length)
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true
                            }
                        }
                    }
                }
            });
        } else {
            currentChart = new Chart(chartCtx, {
                type: chartType,
                data: { datasets: allDatasets },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true
                            },
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                const meta = ci.getDatasetMeta(index);
                                if (meta.hidden === null) {
                                    meta.hidden = !ci.data.datasets[index].hidden;
                                } else {
                                    meta.hidden = null;
                                }
                                ci.update();
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: timeUnitMap[selectedTimeRange] || 'day' },
                            title: { display: true, text: 'time' },
                            ticks: { autoSkip: true, maxTicksLimit: 10 }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'value' }
                        }
                    }
                },
                plugins: [{
                    id: 'fitFormulaLabel',
                    afterDraw(chart) {
                        const ctx = chart.ctx;
                        let y = 30;
                        chart.data.datasets.forEach((ds, i) => {
                            if (ds.fitFormula) {
                                ctx.save();
                                ctx.font = 'bold 13px Segoe UI';
                                ctx.fillStyle = ds._fitColor || '#0e838f';
                                ctx.textBaseline = 'top';
                                ctx.fillText(ds.fitFormula, 60, y);
                                y += 20;
                                ctx.restore();
                            }
                        });
                    }
                }]
            });
        }
        showChartStats(datasets, fitLines);
    }

    function showChartStats(datasets, fitLines) {
        let statsHtml = '';
        if (!datasets || !datasets.length) {
            document.getElementById('chartStats')?.remove();
            return;
        }
        statsHtml += `<div style="margin-top:15px;" id="chartStats"><h3>Statistical analysis</h3>`;
        statsHtml += `<table style="border-collapse:collapse;width:100%;background:#fff;border-radius:8px;box-shadow:0 2px 8px #eee;">`;
        statsHtml += `<tr style="background:#0e838f;color:#fff;"><th>Name</th><th>Mean</th><th>Max</th><th>Min</th><th>Trend</th></tr>`;
        datasets.forEach(ds => {
            const values = ds.data.map(p => p.y);
            if (!values.length) return;
            const avg = (values.reduce((a,b)=>a+b,0)/values.length).toFixed(2);
            const max = Math.max(...values).toFixed(2);
            const min = Math.min(...values).toFixed(2);
            const trend = values[0] < values[values.length-1] ? 'Increasing' : (values[0] > values[values.length-1] ? 'Decreasing' : 'Stable');
            statsHtml += `<tr>
                <td>${ds.label}</td>
                <td>${avg}</td>
                <td>${max}</td>
                <td>${min}</td>
                <td>${trend}</td>
            </tr>`;
        });
        statsHtml += `</table>`;

        if (fitLines && fitLines.length) {
            statsHtml += `<div style="margin-top:10px;">`;
            fitLines.forEach(fit => {
                statsHtml += `<span style="display:inline-block;margin-right:20px;color:${fit._fitColor};font-weight:bold;">${fit.fitFormula}</span>`;
            });
            statsHtml += `</div>`;
        }
        statsHtml += `</div>`;

        let statsDiv = document.getElementById('chartStats');
        if (!statsDiv) {
            statsDiv = document.createElement('div');
            statsDiv.id = 'chartStats';
            document.getElementById('sensorDataChart').parentNode.appendChild(statsDiv);
        }
        statsDiv.outerHTML = statsHtml;
    }

    function linearFit(points) {
        const n = points.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
        for (let i = 0; i < n; i++) {
            const x = i, y = points[i].y;
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        const k = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX + 1e-8);
        const b = (sumY - k * sumX) / n;
        return {k, b};
    }

    async function loadWidgets() {
        if (!selectedDeviceId) {
            widgetContainer.innerHTML = 'è¯·å…ˆé€‰æ‹©è®¾å¤‡';
            return;
        }
        const res = await fetch(`/api/controls?device_id=${selectedDeviceId}`);
        const controls = await res.json();
        widgets = controls;
        renderWidgets();
    }

    function renderWidgets() {
        widgetContainer.innerHTML = '';
        widgets.forEach(w => {
            const div = document.createElement('div');
            div.className = 'widget';
            div.innerHTML = `
              <button class="closeBtn" data-id="${w.control_id}">Ã—</button>
              <h4>${w.control_name || w.control_type}</h4>
              <p>Staus: <strong>${w.state || 'unknown'}</strong></p>
              <button class="toggleBtn">${w.state === 'on' ? 'OFF' : 'ON'}</button>
            `;
            div.querySelector('.closeBtn').onclick = () => {
                widgets = widgets.filter(x => x.control_id !== w.control_id);
                fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'DELETE'
                }).then(resp => {
                    if (resp.ok) {
                        renderWidgets();
                    } else {
                        alert('Delete failed');
                    }
                });
                renderWidgets();
            };
            div.querySelector('.toggleBtn').onclick = async () => {
                const newState = w.state === 'on' ? 'off' : 'on';

                fetch('/api/messages', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        control_id: w.control_id,
                        state: newState,
                        device_id: w.device_id,
                        from_source: 'web'
                    })
                });

                const resp = await fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({state: newState})
                });
                if (resp.ok) {
                    w.state = newState;
                    renderWidgets();
                } else {
                    alert('Update failed');
                }
            };
            widgetContainer.appendChild(div);
        });
    }

    function setupEventListeners() {
        deviceSelect.addEventListener('change', async () => {
            console.log('Device changed:', deviceSelect.value);
            selectedDeviceId = deviceSelect.value;
            sensorSelect.selectedIndex = -1;
            await loadSensors(selectedDeviceId);
            await loadWidgets();
            selectedSensorIds = [];
            if (localStorage.getItem('iot-dashboard-deviceId') !== selectedDeviceId) {
                localStorage.setItem('iot-dashboard-deviceId', selectedDeviceId);
            }
            await loadAndRenderSensorData();
        });

        sensorSelect.addEventListener('change', () => {
            selectedSensorIds = Array.from(sensorSelect.selectedOptions).map(opt => opt.value);
            if ( localStorage.getItem('iot-dashboard-sensorId') !== selectedSensorIds)
            {localStorage.setItem('iot-dashboard-sensorId', selectedSensorIds);}

            reloadTimeRangeBtn();
            loadAndRenderSensorData();
        });

        timeRangeButtons.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedTimeRange = btn.dataset.range;
                localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
                loadAndRenderSensorData();
            });
        });

        chartTypeSelect.addEventListener('change', () => {
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            selectedChartType = chartTypeSelect.value;
            const datasets = chartDataCache.map((d,i) => ({
                label: `${d.field} (Sensor:${d.sensorId})`,
                data: d.points,
                borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2
            }));
            renderChart(datasets);
        });

        saveSettingsBtn.addEventListener('click', () => {
            saveSettingsToLocal();
            alert('Setting saved to localStorage');
        });

        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;

        defaultTimeRangeSelect.addEventListener('change', (e) => {
            selectedTimeRange = e.target.value;
            timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            const btn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
            if (btn) btn.classList.add('active');
            loadAndRenderSensorData();
        });

        defaultChartTypeSelect.addEventListener('change', (e) => {
            selectedChartType = e.target.value;
            chartTypeSelect.value = selectedChartType;
            loadAndRenderSensorData();
        });

        addWidgetBtn.addEventListener('click', async () => {
            if (!selectedDeviceId) {
                return alert('Please select a device sensor first');
            }
            const sensor_id = sensorSelect.value;
            const name = prompt('Please enter widget name');
            const type = prompt('Please enter type (button/slider/switch)');
            if (!name || !type) return alert('name and type cannot be empty');
            const resp = await fetch('/api/controls', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({control_id:sensor_id,device_id: selectedDeviceId, control_name: name, control_type: type,
                    state: 'off'})
            });
            if (resp.ok) {
                await loadWidgets();
            } else {
                alert('Add widget failed');
            }
        });

        autoRefreshCheckbox.addEventListener('change', startAutoRefresh);
        autoRefreshIntervalInput.addEventListener('change', startAutoRefresh);

        document.getElementById('btnAddDevice').addEventListener('click', addTestDevice);

        document.getElementById('btnAddControl').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            if (!lastSensorId) {
                lastDeviceId = await addTestSensor();
            }

            await addTestControl(lastDeviceId);
        });

        document.getElementById('btnAddSensor').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            await addTestSensor(lastDeviceId);
        });

        document.getElementById('btnAddSensorData').addEventListener('click', async () => {
            if (!lastSensorId) {
                alert('Please add a sensor first');
                return;
            }
            await addTestSensorData(lastSensorId);
        });

        document.getElementById('btnAddAll').addEventListener('click', addTestAll);

        document.getElementById('btnTestDelete').addEventListener('click', async () => {
            const radios = document.querySelectorAll('input[name="testDeviceRadio"]:checked');
            const deviceId = radios.length ? radios[0].value : null;
            if (!deviceId) {
                alert('Pls select Test Device you want to delete');
                return;
            }
            if (!confirm(`Delete device ${deviceId} and all related data?`)) return;

            try {
                await fetch(`/api/controls?device_id=${deviceId}`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async controls => {
                        for (const ctrl of controls) {
                            await fetch(`/api/controls?control_id=${ctrl.control_id}`, { method: 'DELETE' });
                        }
                    });

                await fetch(`/api/sensors?device_id=${deviceId}&limit=100`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async sensors => {
                        for (const sensor of sensors) {
                            await fetch(`/api/sensor_data?sensor_id=${sensor.sensor_id}`, { method: 'GET' })
                                .then(res => {
                                    if (res.ok) {
                                        return res.json();
                                    } else {
                                        throw new Error('Failed to fetch sensor data');
                                    }

                                });
                            await fetch(`/api/sensors?sensor_id=${sensor.sensor_id}`, { method: 'DELETE' });
                        }
                    });

                await fetch(`/api/device?device_id=${deviceId}`, { method: 'DELETE' });

                localStorage.removeItem('lastDeviceId');
                localStorage.removeItem('lastControlId');
                localStorage.removeItem('lastSensorId');
                localStorage.removeItem('lastSensorDataId');

                document.getElementById('lastDeviceInfo').textContent = 'No lastDeviceId';
                loadTestDeviceList();
                alert('Device and related data deleted.');
            } catch (e) {
                alert('Delete failed: ' + e);
            }
        });

    }

    async function addTestDevice() {
        const testDevice = {
            device_name: 'Test Device '+ Date.now(),
            device_type: 'test_type'
        };
        const res = await fetch('/api/device', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testDevice)
        });
        const data = await res.json();
        if (!data.insertedId) {
            alert('Add device failed');
            return null;
        }
        localStorage.setItem('lastDeviceId', data.insertedId);
        lastDeviceId = data.insertedId;
        alert('Added device ID: '+data.insertedId);
        await loadTestDeviceList();
        return data.insertedId;
    }

    async function addTestControl(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testControl = {
            device_id: deviceId,
            control_id: lastSensorId,
            control_type: 'button',
            control_name: 'Test Control',
            state: 'off'
        };
        const res = await fetch('/api/controls', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testControl)
        });
        const data = await res.json();
        if (!data.control_id) {
            alert('Add control failed');
            return null;
        }
        localStorage.setItem('lastControlId', data.control_id);
        lastControlId= data.control_id;
        alert('Added control ID: ' + data.control_id);
        return data.control_id;
    }

    async function addTestSensor(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testSensor = {
            device_id: deviceId,
            sensor_type: 'temperature',
            sensor_name: 'Test Sensor'
        };
        const res = await fetch('/api/sensors', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSensor)
        });
        const data = await res.json();
        if (!data.sensor_id) {
            alert('Add sensor failed');
            return null;
        }
        localStorage.setItem('lastSensorId', data.sensor_id);
        lastSensorId= data.sensor_id;
        alert('Added sensor ID: ' + data.sensor_id);
        await loadTestDeviceList();
        return data.sensor_id;
    }

    async function addTestSensorData(sensorId) {
        if (!sensorId) {
            alert('Please add or select a sensor first');
            return;
        }
        const testData = {
            sensor_id: sensorId,
            timestamp: Math.floor(Date.now() / 1000),
            data: { temperature: (20 + Math.random() * 10).toFixed(2), humidity: (40 + Math.random() * 20).toFixed(2) }
        };
        const res = await fetch('/api/sensor_data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testData)
        });
        const data = await res.json();
        if (!data.data_id) {
            alert('Add sensor data failed');
            return null;
        }
        localStorage.setItem('lastSensorDataId', data.data_id);
        alert('Added sensor data ID: ' + data.data_id);
        return data.data_id;
    }

    async function addTestAll() {
        const deviceId = await addTestDevice();
        if (!deviceId) return;
        const controlId = await addTestControl(deviceId);
        const sensorId = await addTestSensor(deviceId);
        if (sensorId) {
            await addTestSensorData(sensorId);
        }
        alert('Add datas successfully!');
    }

    function saveSettingsToLocal() {
        localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
        localStorage.setItem('iot-dashboard-chartType', selectedChartType);
        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;
    }

    function loadSettings() {
        selectedTimeRange = localStorage.getItem('iot-dashboard-timeRange') || 'hour';
        selectedChartType = localStorage.getItem('iot-dashboard-chartType') || 'line';

    }

    let lastMessageTimestamp = Math.floor(Date.now() / 1000);



    async function checkNewMessages() {
        const resp = await fetch(`/api/messages?after=${lastMessageTimestamp}`);
        const messages = await resp.json();
        if (!messages.length) return;

        messages.sort((a, b) => a.created_at - b.created_at);

        for (const msg of messages) {
            lastMessageTimestamp = Math.max(lastMessageTimestamp, msg.created_at);
            if (msg.from_source.startsWith('web')) continue;
            updateWidgetState(msg.control_id, msg.state);
        }
    }

    function updateWidgetState(control_id, state) {
        const widget = widgets.find(w => w.control_id === control_id);
        if (widget) {
            widget.state = state;
            renderWidgets();
        }
    }

    function reloadTimeRangeBtn(){
        timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const activeBtn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
        if (activeBtn) activeBtn.classList.add('active');
    }

    async function loadTestDeviceList() {
        const res = await fetch('/api/device?device_name=test&limit=100');
        const devices = await res.json();
        const testDeviceList = document.getElementById('testDeviceList');
        testDeviceList.innerHTML = '';
        if (!devices.length) {
            testDeviceList.innerHTML = '<span style="color:#e74c3c;">No test device found.</span>';
            document.getElementById('testSensorList').innerHTML = '';
            document.getElementById('lastDeviceInfo').textContent = 'No lastDeviceId';
            return;
        }
        devices.forEach((d, idx) => {
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'testDeviceRadio';
            radio.value = d.device_id;
            if (idx === 0) radio.checked = true;
            radio.addEventListener('change', () => {
                localStorage.setItem('lastDeviceId', d.device_id);
                loadTestSensorList(d.device_id);
                document.getElementById('lastDeviceInfo').textContent = `lastDeviceId: ${d.device_id}`;
            });
            testDeviceList.appendChild(radio);
            const label = document.createElement('label');
            label.textContent = `${d.device_name} (${d.device_id})`;
            label.style.marginRight = '15px';
            testDeviceList.appendChild(label);
        });
        const firstId = devices[0].device_id;
        localStorage.setItem('lastDeviceId', firstId);
        document.getElementById('lastDeviceInfo').textContent = `lastDeviceId: ${firstId}`;
        loadTestSensorList(firstId);
    }

    async function loadTestSensorList(deviceId) {
        if (!deviceId) {
            document.getElementById('testSensorList').innerHTML = '';
            return;
        }
        const res = await fetch(`/api/sensors?device_id=${deviceId}&limit=100`);
        const sensors = await res.json();
        const testSensorList = document.getElementById('testSensorList');
        testSensorList.innerHTML = '';
        if (!sensors.length) {
            testSensorList.innerHTML = '<span style="color:#e74c3c;">No sensor found.</span>';
            return;
        }
        sensors.forEach((s, idx) => {
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'testSensorRadio';
            radio.value = s.sensor_id;
            if (idx === 0) radio.checked = true;
            radio.addEventListener('change', () => {
                localStorage.setItem('lastSensorId', s.sensor_id);
            });
            testSensorList.appendChild(radio);
            const label = document.createElement('label');
            label.textContent = `${s.sensor_name} (${s.sensor_id})`;
            label.style.marginRight = '15px';
            testSensorList.appendChild(label);
        });
        localStorage.setItem('lastSensorId', sensors[0].sensor_id);
    }

</script>
</body>
</html>
