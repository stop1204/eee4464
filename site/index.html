<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EEE4464 IoT Dashboard</title>
    <link rel="stylesheet" href="https://static.integrations.cloudflare.com/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f5f7fa; }
        header { padding: 10px 20px; background: #0e838f; color: white; }
        header h1 { margin: 0; font-weight: 700; }
        nav { display: flex; border-bottom: 2px solid #ddd; background: white; }
        nav button {
            flex: 1; padding: 15px; border: none; background: #eee; cursor: pointer; font-weight: 600;
            transition: background-color 0.3s ease;
        }
        nav button.active, nav button:hover {
            background: #0e838f; color: white; box-shadow: 0 4px 10px rgba(14,131,143,.5);
        }
        main { padding: 20px; }
        .tab-content { display: none; animation: fadeIn 0.5s ease forwards; }
        .tab-content.active { display: block; }
        @keyframes fadeIn {
            from {opacity:0; transform: translateY(20px);}
            to {opacity:1; transform: translateY(0);}
        }

        /* Widget layout */
        #widgetContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .widget {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1);
            position: relative;
            transition: transform 0.2s ease;
        }
        .widget:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(14,131,143,0.4);
        }
        .widget .closeBtn {
            position: absolute;
            top: 8px; right: 8px;
            background: #e74c3c;
            border: none;
            border-radius: 50%;
            width: 22px; height: 22px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        .widget .closeBtn:hover {
            opacity: 1;
        }

        /* buttons */
        .btn-group button {
            padding: 8px 15px;
            margin: 0 3px 10px 0;
            border: none;
            background: #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .btn-group button.active, .btn-group button:hover {
            background: #0e838f;
            color: white;
        }

        /* check box */
        select {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }


        #sensorDataChart {
            width: 100% !important;
            max-width: 800px;
            height: auto !important;
            aspect-ratio: 2/1;
            display: block;
            margin: 0 auto;
        }
        @media (max-width: 600px) {
            main {
                padding: 5px;
            }
            #sensorDataChart {
                max-width: 100vw;
                height: auto !important;
            }
        }
    </style>
</head>
<body>
<header>
    <h1>ðŸŒŸ EEE4464 IoT Dashboard</h1>
</header>

<nav>
    <button class="tabBtn active" data-tab="dashboard">Dashboard</button>
    <button class="tabBtn" data-tab="widgets">Widgets</button>
    <button class="tabBtn" data-tab="settings">Settings</button>
    <button class="tabBtn" data-tab="test">Test</button>
</nav>

<main>
    <!-- Dashboard Tab -->
    <section id="dashboard" class="tab-content active">
        <div style="margin:10px 0;">
            <label><input type="checkbox" id="autoRefreshCheckbox" /> Auto Refresh</label>
            <input type="number" id="autoRefreshInterval" value="1" min="1" style="width:60px;" /> seconds
        </div>
        <div>
            <label>Select Device:</label><br />
            <select id="deviceSelect"><option>Loading...</option></select>
        </div>
        <div>
            <label>Select Sensors (multiple):</label><br />
            <select id="sensorSelect" multiple size="5"></select>
        </div>
        <div class="btn-group" id="timeRangeButtons">
            <button data-range="hour" class="active">Hour</button>
            <button data-range="day">Day</button>
            <button data-range="week">Week</button>
            <button data-range="month">Month</button>
            <button data-range="year">Year</button>
        </div>
        <div>
            <label>Select Chart Type:</label><br />
            <select id="chartTypeSelect">
                <option value="line" selected>Line</option>
                <option value="bar">Bar</option>
                <option value="pie">Pie</option>
                <option value="doughnut">Doughnut</option>
                <option value="radar">Radar</option>
            </select>
        </div>
        <canvas id="sensorDataChart" width="800" height="400" style="max-width: 800px; height: 400px;"></canvas>
    </section>

    <!-- Widgets Tab -->
    <section id="widgets" class="tab-content">
        <button id="addWidgetBtn">Add Status Widget</button>
        <div id="widgetContainer"></div>
    </section>

    <!-- Settings Tab -->
    <section id="settings" class="tab-content">
        <h2>User Settings</h2>
        <p>Current settings are saved in browser <code>localStorage</code> and will not sync across devices.</p>
        <label>Default Time Range:</label>
        <select id="defaultTimeRangeSelect">
            <option value="hour">Hour</option>
            <option value="day">Day</option>
            <option value="week">Week</option>
            <option value="month">Month</option>
            <option value="year">Year</option>
        </select>
        <br/>
        <label>Default Chart Type:</label>
        <select id="defaultChartTypeSelect">
            <option value="line">Line</option>
            <option value="bar">Bar</option>
            <option value="pie">Pie</option>
            <option value="doughnut">Doughnut</option>
            <option value="radar">Radar</option>
        </select>
        <br/><br/>
        <button id="saveSettingsBtn">Save Settings</button>
    </section>
    <!-- Test Tab -->
    <section id="test" class="tab-content">
        <h2>Test Add Data</h2>
        <button id="btnAddDevice">Add Device</button>
        <button id="btnAddSensor">Add Sensor (add device first)</button>
        <button id="btnAddControl">Add Control (add sensor first)</button>
        <button id="btnAddSensorData">Add Sensor Data (add sensor first)</button>
        <button id="btnAddAll">Add All Test Data</button>
        <div style="margin-top:10px;">
            <button id="btnTestDelete">Test Delete</button>
            <span id="lastDeviceInfo" style="margin-left:10px;color:#0e838f;font-weight:bold;"></span>
        </div>
    </section>
</main>
<script>

    // chart
    let autoRefreshTimer = null;
    let chartDataCache = []; // all sensor data cache
    let chartLastTimestamp = 0;

    // local storage variables
    let lastDeviceId = localStorage.getItem('lastDeviceId') || null;
    let lastControlId = localStorage.getItem('lastControlId') || null;
    let lastSensorId = localStorage.getItem('lastSensorId') || null;
    let lastSensorDataId = localStorage.getItem('lastSensorDataId') || null;

    // --- TAB ---
    const tabs = document.querySelectorAll('.tabBtn');
    const contents = document.querySelectorAll('.tab-content');
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            contents.forEach(c => c.classList.remove('active'));
            document.getElementById(tab.dataset.tab).classList.add('active');

            // Show lastDeviceId beside testDelete button when Test tab is active
            if (tab.dataset.tab === 'test') {
                const lastDeviceId = localStorage.getItem('lastDeviceId') || '';
                document.getElementById('lastDeviceInfo').textContent = lastDeviceId ? `lastDeviceId: ${lastDeviceId}` : 'No lastDeviceId';
            }
        });
    });

    // --- variables ---
    const deviceSelect = document.getElementById('deviceSelect');
    const sensorSelect = document.getElementById('sensorSelect');
    const timeRangeButtons = document.getElementById('timeRangeButtons');
    const chartTypeSelect = document.getElementById('chartTypeSelect');
    const chartCtx = document.getElementById('sensorDataChart').getContext('2d');
    const widgetContainer = document.getElementById('widgetContainer');
    const addWidgetBtn = document.getElementById('addWidgetBtn');
    const defaultTimeRangeSelect = document.getElementById('defaultTimeRangeSelect');
    const defaultChartTypeSelect = document.getElementById('defaultChartTypeSelect');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
    const autoRefreshIntervalInput = document.getElementById('autoRefreshInterval');

    let currentChart = null;
    let renderPending = false;
    let lastDatasets = null;
    let updating = false;
    // remember each line's color
    let lineColors = {};

    let selectedDeviceId = null;
    let selectedSensorIds = [];
    let selectedTimeRange = 'hour';
    let selectedChartType = 'line';
    let widgets = [];

    function getLineColor(label, idx) {
        if (!lineColors[label]) {
            const baseColors = [
                '#0e838f', '#8a2be2', '#ff7f50', '#ffdc34', '#0ecb81', '#c74e4e', '#bc7af9',
                '#f08a5d', '#f9ed69', '#3ec1d3', '#ffb6b9', '#283c63'
            ];
            lineColors[label] = baseColors[idx % baseColors.length];
        }
        return lineColors[label];
    }

    // init dataset
    const datasets = chartDataCache.map((d, i) => ({
        label: `${d.field} (Sensor:${d.sensorId})`,
        data: d.points,
        borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
        backgroundColor: 'transparent',
        fill: false,
        tension: 0.2,
        pointRadius: 2
    }));
    function startAutoRefresh() {
        if (autoRefreshTimer) clearInterval(autoRefreshTimer);
        if (!autoRefreshCheckbox.checked) return;
        autoRefreshTimer = setInterval(() => {
            fetchNewSensorData();
        }, Number(autoRefreshIntervalInput.value) * 1000);
    }

    // --- init ---
    async function init() {
        loadSettings();
        await loadDevices();
        await loadAndRenderSensorData();
        setupEventListeners();
        startAutoRefresh();
    }

    // --- load devices ---

    async function loadDevices() {
        const res = await fetch('/api/device?limit=100');
        const devices = await res.json();
        // @ts-ignore
        deviceSelect.innerHTML = '<option value="">--Please Select Device--</option>' + devices.map(function(d) {
            return '<option value="' + d.device_id + '">' + d.device_name +'-'+d.device_type +'-'+d.device_id +'</option>';
        }).join('');
        // if not empty
        if (deviceSelect.children.length > 1){
            // iter chidren
            deviceid = localStorage.getItem('iot-dashboard-deviceId');
            if (deviceid) {
                const found = Array.from(deviceSelect.children).find(opt => opt.value === deviceid);
                if (found) {
                    // this is wrong, need to trigger 'change' event
                    // wait DOM ready
                    setTimeout(() => {
                        deviceSelect.value = deviceid;
                        selectedDeviceId = deviceid;
                        deviceSelect.dispatchEvent(new Event('change', {bubbles: true}));
                    },0);
                } else {
                    deviceSelect.selectedIndex = 0; // reset to default
                    selectedDeviceId = null;
                }
            } else {
                deviceSelect.selectedIndex = 0; // reset to default
                selectedDeviceId = null;
            }

        }
    }

    // --- loading sensors ---

    async function loadSensors(deviceId) {
        if (!deviceId) {
            sensorSelect.innerHTML = '';
            return;
        }
        const res = await fetch(`/api/sensors?device_id=${deviceId}&limit=100`);
        const sensors = await res.json();
        sensorSelect.innerHTML = sensors.length ? sensors.map(function(s) {
            return '<option value="' + s.sensor_id + '">' + s.sensor_name + ' (' + (s.sensor_type || 'unknown') + '-' + s.sensor_id + ')</option>';
        }).join('') : '<option>No sensor</option>';
        // if not empty
        if (sensorSelect.children.length > 0) {
            // this is an array obj
            const sensorIds = localStorage.getItem('iot-dashboard-sensorId');

            if (sensorIds) {
                // wait DOM ready
                setTimeout(() => {
                    const ids = sensorIds.split(',').map(id => id.trim());

                    Array.from(sensorSelect.options).forEach(opt => {
                        opt.selected = ids.includes(opt.value);
                    })
                    sensorSelect.dispatchEvent(new Event('change', {bubbles: true}));
                },0);
            } else {
                sensorSelect.selectedIndex = -1; // reset to default
                selectedSensorIds = [];
            }
        } else {
            selectedSensorIds = [];
        }
    }

    // --- load and render trending data ---
    async function loadAndRenderSensorData() {
        if (updating) return;
        updating = true;
        if (!selectedSensorIds.length) {
            renderChart([]);
            chartDataCache = [];
            chartLastTimestamp = 0;
            updating = false;
            return;
        }
        const now = Math.floor(Date.now() / 1000);
        let start;
        switch(selectedTimeRange) {
            case 'hour': start = now - 3600; break;
            case 'day': start = now - 86400; break;
            case 'week': start = now - 86400*7; break;
            case 'month': start = now - 86400*30; break;
            case 'year': start = now - 86400*365; break;
            default: start = now - 3600;
        }

        // load all data save to cache
        chartDataCache = [];
        chartLastTimestamp = 0;

        // load all exist sensor
        await Promise.all(selectedSensorIds.map(async (sensorId) => {
            const resp = await fetch(`/api/sensor_data?sensor_id=${sensorId}&start=${start}&end=${now}&limit=1000`);
            const data = await resp.json();
            if (!data.length) return;
            // get all fields from first data
            const allFields = Object.keys(JSON.parse(data[0].data));
            allFields.forEach(field => {
                const points = data.map(d => ({
                    x: d.timestamp * 1000,
                    y: parseFloat(JSON.parse(d.data)[field])
                })).reverse(); // time order
                chartDataCache.push({
                    sensorId,
                    field,
                    points
                });
            });
            // record last timestamp
            chartLastTimestamp = Math.max(chartLastTimestamp, ...data.map(d => d.timestamp * 1000));
        }));

        // compose datasets
        const datasets = chartDataCache.map((d,i) => ({
            label: `${d.field} (Sensor:${d.sensorId})`,
            data: d.points,
            borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
            backgroundColor: 'transparent',
            fill: false,
            tension: 0.2,
            pointRadius: 2
        }));

        renderChart(datasets);
        updating = false;
    }

    // auto refresh
    async function fetchNewSensorData() {
        if (!selectedSensorIds.length || !chartLastTimestamp) return;
        const now = Math.floor(Date.now() / 1000);
        let hasUpdate = false;
        // add new data to chartDataCache, depending on cache sensorId and field
        await Promise.all(chartDataCache.map(async (d) => {
            const resp = await fetch(`/api/sensor_data?sensor_id=${d.sensorId}&start=${Math.floor(chartLastTimestamp/1000)+1}&end=${now}&limit=100`);
            const data = await resp.json();
            if (!data.length) return;
            // new data only pull field
            const newPoints = [];
            data.forEach(row => {
                const val = JSON.parse(row.data)[d.field];
                if (val !== undefined) {
                    newPoints.push({
                        x: row.timestamp * 1000,
                        y: parseFloat(val)
                    });
                }
            });
            if (newPoints.length) {
                d.points = d.points.concat(newPoints);
                hasUpdate = true;
            }
        }));

        if (hasUpdate) {
            // update lastest timestamp
            chartLastTimestamp = Math.max(...chartDataCache.map(d => d.points.length ? d.points[d.points.length-1].x : 0));
            // re-compose datasets
            const datasets = chartDataCache.map((d,i) => ({
                label:`${d.field} (Sensor:${d.sensorId})`,
                data: d.points,
                borderColor:  getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2,
                pointRadius: 2
            }));
            renderChart(datasets);
        }
    }

    // --- render Chart.js chart ---
    function renderChart(datasets) {
        // if (currentChart) {
        //   currentChart.destroy();
        //   currentChart = null;
        // }
        const timeUnitMap = {
            hour: 'minute',
            day: 'hour',
            week: 'day',
            month: 'day',
            year: 'month'
        };

        // only one dataset for pie/doughnut chart
        if (selectedChartType === 'pie' || selectedChartType === 'doughnut') {
            // get all datasets with same sensorId, or merge all points
            const first = datasets[0];
            if (!first) return;

            if (!currentChart) {
                currentChart = new Chart(chartCtx, {
                    type: selectedChartType,
                    data: {
                        labels: first.data.map(p => new Date(p.x).toLocaleString()),
                        datasets: [{
                            label: first.label,
                            data: first.data.map(p => p.y),
                            backgroundColor: pieColors(first.data.length) //
                        }]
                    },
                    options: {
                        responsive: false,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: true } }
                    }
                });
            } else {
                currentChart.labels = first.data.map(p => new Date(p.x).toLocaleString());

                currentChart.data.datasets = datasets;
                currentChart.update('none');
            }

        } else {
            if (!currentChart) {
                // line, bar, radar

                currentChart = new Chart(chartCtx, {
                    type: selectedChartType,
                    data: { datasets },
                    options: {
                        responsive: false,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: true } },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: timeUnitMap[selectedTimeRange] || 'day' },
                                title: { display: true, text: 'time' },
                                ticks: { autoSkip: true, maxTicksLimit: 10 }
                            },
                            y: {
                                beginAtZero: true,
                                title: { display: true, text: 'value' }
                            }
                        }
                    }
                });
            } else {
                currentChart.data.datasets = datasets;
                currentChart.update('none');
            }
        }
    }

    // pie colors
    function pieColors(count) {
        // return count colors from a predefined set
        const baseColors = [
            '#0e838f', '#8a2be2', '#ff7f50', '#ffdc34', '#0ecb81', '#c74e4e', '#bc7af9',
            '#f08a5d', '#f9ed69', '#3ec1d3', '#ffb6b9', '#283c63'
        ];
        return Array(count).fill(0).map((_,i)=>baseColors[i%baseColors.length]);
    }

    function randomColor() {
        return 'hsl(' + Math.floor(Math.random() * 360) + ', 70%, 50%)';
    }

    async function loadWidgets() {
        if (!selectedDeviceId) {
            widgetContainer.innerHTML = 'è¯·å…ˆé€‰æ‹©è®¾å¤‡';
            return;
        }
        const res = await fetch(`/api/controls?device_id=${selectedDeviceId}`);
        const controls = await res.json();
        widgets = controls;
        renderWidgets();
    }

    function renderWidgets() {
        widgetContainer.innerHTML = '';
        widgets.forEach(w => {
            const div = document.createElement('div');
            div.className = 'widget';
            div.innerHTML = `
              <button class="closeBtn" data-id="${w.control_id}">Ã—</button>
              <h4>${w.control_name || w.control_type}</h4>
              <p>Staus: <strong>${w.state || 'unknown'}</strong></p>
              <button class="toggleBtn">${w.state === 'on' ? 'OFF' : 'ON'}</button>
            `;
            // delete button
            div.querySelector('.closeBtn').onclick = () => {
                widgets = widgets.filter(x => x.control_id !== w.control_id);
                // remove from database
                fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'DELETE'
                }).then(resp => {
                    if (resp.ok) {
                        renderWidgets();
                    } else {
                        alert('Delete failed');
                    }
                });
                renderWidgets();
            };
            // on/off button
            div.querySelector('.toggleBtn').onclick = async () => {

                const newState = w.state === 'on' ? 'off' : 'on';

                fetch('/api/messages', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        control_id: w.control_id,
                        state: newState,
                        device_id: w.device_id,
                        from_source: 'web'
                    })
                });


                const resp = await fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({state: newState})
                });
                if (resp.ok) {
                    w.state = newState;
                    renderWidgets();
                } else {
                    alert('Update failed');
                }
            };
            widgetContainer.appendChild(div);
        });
    }

    // --- events listening ---
    function setupEventListeners() {
        deviceSelect.addEventListener('change', async () => {
            console.log('Device changed:', deviceSelect.value);
            selectedDeviceId = deviceSelect.value;
            // this need to set before load sensors
            sensorSelect.selectedIndex = -1;
            await loadSensors(selectedDeviceId);
            await loadWidgets();
            selectedSensorIds = [];
            if (localStorage.getItem('iot-dashboard-deviceId') !== selectedDeviceId) {
                localStorage.setItem('iot-dashboard-deviceId', selectedDeviceId);
            }
            await loadAndRenderSensorData();
        });

        sensorSelect.addEventListener('change', () => {
            selectedSensorIds = Array.from(sensorSelect.selectedOptions).map(opt => opt.value);
            if ( localStorage.getItem('iot-dashboard-sensorId') !== selectedSensorIds)
            {localStorage.setItem('iot-dashboard-sensorId', selectedSensorIds);}

            reloadTimeRangeBtn();
            loadAndRenderSensorData();
        });

        timeRangeButtons.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedTimeRange = btn.dataset.range;
                localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
                // saveSettingsToLocal();
                loadAndRenderSensorData();  // this is importance
            });
        });

        chartTypeSelect.addEventListener('change', () => {
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            selectedChartType = chartTypeSelect.value;
            // saveSettingsToLocal();
            // no need to fetch data again, just re-render chart with cached data
            const datasets = chartDataCache.map((d,i) => ({
                label: d.labelKey + ' (ID:' + d.sensorId + ')',
                data: d.points,
                borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2
            }));
            renderChart(datasets);
        });

        saveSettingsBtn.addEventListener('click', () => {
            saveSettingsToLocal();
            alert('Setting saved to localStorage');
        });

        // init settings panel
        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;

        defaultTimeRangeSelect.addEventListener('change', (e) => {
            selectedTimeRange = e.target.value;
            timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            const btn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
            if (btn) btn.classList.add('active');
            // saveSettingsToLocal();
            loadAndRenderSensorData();
        });

        defaultChartTypeSelect.addEventListener('change', (e) => {
            selectedChartType = e.target.value;
            chartTypeSelect.value = selectedChartType;
            // saveSettingsToLocal();
            loadAndRenderSensorData();
        });

        addWidgetBtn.addEventListener('click', async () => {
            // simple prompt for control_name and control_type
            if (!selectedDeviceId) {
                return alert('Please select a device sensor first');
            }
            const sensor_id = sensorSelect.value;
            const name = prompt('Please enter widget name');
            const type = prompt('Please enter type (button/slider/switch)');
            if (!name || !type) return alert('name and type cannot be empty');
            const resp = await fetch('/api/controls', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({control_id:sensor_id,device_id: selectedDeviceId, control_name: name, control_type: type,
                    state: 'off'})
            });
            if (resp.ok) {
                await loadWidgets();
            } else {
                alert('Add widget failed');
            }
        });


        // auto refresh chart

        autoRefreshCheckbox.addEventListener('change', startAutoRefresh);
        autoRefreshIntervalInput.addEventListener('change', startAutoRefresh);


        // Add Test buttons
        document.getElementById('btnAddDevice').addEventListener('click', addTestDevice);



        document.getElementById('btnAddControl').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            if (!lastSensorId) {
                lastDeviceId = await addTestSensor();
            }

            await addTestControl(lastDeviceId);
        });

        document.getElementById('btnAddSensor').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            await addTestSensor(lastDeviceId);
        });

        document.getElementById('btnAddSensorData').addEventListener('click', async () => {
            if (!lastSensorId) {
                alert('Please add a sensor first');
                return;
            }
            await addTestSensorData(lastSensorId);
        });

        document.getElementById('btnAddAll').addEventListener('click', addTestAll);

        // Test Delete button logic
        document.getElementById('btnTestDelete').addEventListener('click', async () => {
            const lastDeviceId = localStorage.getItem('lastDeviceId');
            if (!lastDeviceId) {
                alert('No lastDeviceId found.');
                return;
            }
            if (!confirm(`Delete device ${lastDeviceId} and all related data?`)) return;

            try {
                // 1. Delete all controls with this device_id
                await fetch(`/api/controls?device_id=${lastDeviceId}`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async controls => {
                        for (const ctrl of controls) {
                            await fetch(`/api/controls?control_id=${ctrl.control_id}`, { method: 'DELETE' });
                        }
                    });

                // 2. Delete all sensors with this device_id and their sensor_data
                await fetch(`/api/sensors?device_id=${lastDeviceId}&limit=100`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async sensors => {
                        for (const sensor of sensors) {
                            // Delete sensor_data for this sensor
                            await fetch(`/api/sensor_data?sensor_id=${sensor.sensor_id}&limit=1000`, { method: 'GET' })
                                .then(res => res.json())
                                .then(async datas => {
                                    for (const data of datas) {
                                        // If you had a DELETE for sensor_data, you could call it here
                                        // But index.ts does not implement DELETE for sensor_data, so skip
                                    }
                                });
                            // Delete the sensor itself
                            await fetch(`/api/sensors?sensor_id=${sensor.sensor_id}`, { method: 'DELETE' });
                        }
                    });

                // 3. Delete the device itself
                await fetch(`/api/device?device_id=${lastDeviceId}`, { method: 'DELETE' });

                // 4. Clear localStorage keys
                localStorage.removeItem('lastDeviceId');
                localStorage.removeItem('lastControlId');
                localStorage.removeItem('lastSensorId');
                localStorage.removeItem('lastSensorDataId');

                document.getElementById('lastDeviceInfo').textContent = 'No lastDeviceId';
                alert('Device and related data deleted.');
            } catch (e) {
                alert('Delete failed: ' + e);
            }
        });

    }

    async function addTestDevice() {
        const testDevice = {
            device_name: 'Test Device '+ Date.now(),
            device_type: 'test_type'
        };
        const res = await fetch('/api/device', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testDevice)
        });
        const data = await res.json();
        if (!data.insertedId) {
            alert('Add device failed');
            return null;
        }
        localStorage.setItem('lastDeviceId', data.insertedId);
        lastDeviceId = data.insertedId;
        alert('Added device ID: '+data.insertedId);
        return data.insertedId;
    }

    async function addTestControl(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testControl = {
            device_id: deviceId,
            control_id: lastSensorId,
            control_type: 'button',
            control_name: 'Test Control',
            state: 'off'
        };
        const res = await fetch('/api/controls', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testControl)
        });
        const data = await res.json();
        if (!data.control_id) {
            alert('Add control failed');
            return null;
        }
        localStorage.setItem('lastControlId', data.control_id);
        lastControlId= data.control_id;
        alert('Added control ID: ' + data.control_id);
        return data.control_id;
    }

    async function addTestSensor(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testSensor = {
            device_id: deviceId,
            sensor_type: 'temperature',
            sensor_name: 'Test Sensor'
        };
        const res = await fetch('/api/sensors', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSensor)
        });
        const data = await res.json();
        if (!data.sensor_id) {
            alert('Add sensor failed');
            return null;
        }
        localStorage.setItem('lastSensorId', data.sensor_id);
        lastSensorId= data.sensor_id;
        alert('Added sensor ID: ' + data.sensor_id);
        return data.sensor_id;
    }

    async function addTestSensorData(sensorId) {
        if (!sensorId) {
            alert('Please add or select a sensor first');
            return;
        }
        const testData = {
            sensor_id: sensorId,
            timestamp: Math.floor(Date.now() / 1000),
            data: { temperature: (20 + Math.random() * 10).toFixed(2), humidity: (40 + Math.random() * 20).toFixed(2) }
        };
        const res = await fetch('/api/sensor_data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testData)
        });
        const data = await res.json();
        if (!data.data_id) {
            alert('Add sensor data failed');
            return null;
        }
        localStorage.setItem('lastSensorDataId', data.data_id);
        alert('Added sensor data ID: ' + data.data_id);
        return data.data_id;
    }

    // tests compose, add device, control, sensor and sensor data
    async function addTestAll() {
        const deviceId = await addTestDevice();
        if (!deviceId) return;
        const controlId = await addTestControl(deviceId);
        const sensorId = await addTestSensor(deviceId);
        if (sensorId) {
            await addTestSensorData(sensorId);
        }
        alert('Add datas successfully!');
    }

    // --- local storage settings ---
    function saveSettingsToLocal() {
        localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
        localStorage.setItem('iot-dashboard-chartType', selectedChartType);
        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;
    }

    function loadSettings() {
        selectedTimeRange = localStorage.getItem('iot-dashboard-timeRange') || 'hour';
        selectedChartType = localStorage.getItem('iot-dashboard-chartType') || 'line';

    }

    // add variable to record last processed message timestamp
    let lastMessageTimestamp = Math.floor(Date.now() / 1000);

    // set interval to check for new messages every 5 seconds
    setInterval(checkNewMessages, 5000);

    async function checkNewMessages() {
        const resp = await fetch(`/api/messages?after=${lastMessageTimestamp}`);
        const messages = await resp.json();
        if (!messages.length) return;

        // time order messages
        messages.sort((a, b) => a.created_at - b.created_at);

        for (const msg of messages) {
            lastMessageTimestamp = Math.max(lastMessageTimestamp, msg.created_at);
            if (msg.from_source.startsWith('web')) continue; // skip by web(self) source
            // depending on your widget structure, you may need to adjust this
            updateWidgetState(msg.control_id, msg.state);
        }
    }

    // widget state update function
    function updateWidgetState(control_id, state) {
        // process widgets to find the one with control_id
        const widget = widgets.find(w => w.control_id === control_id);
        if (widget) {
            widget.state = state;
            renderWidgets();
        }
    }

    // when click on sensor
    function reloadTimeRangeBtn(){
        timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const activeBtn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
        if (activeBtn) activeBtn.classList.add('active');
    }
    function reloadDevice(){

    }
    function reloadSensor(){

    }

    // --- initial ---
    init();


</script>
</body>
</html>
