<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EEE4464 IoT Dashboard</title>
    <link rel="stylesheet" href="https://static.integrations.cloudflare.com/styles.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 0; background: #f5f7fa; display: flex; flex-direction: column; min-height: 100vh; }
        header { padding: 10px 20px; background: #0e838f; color: white; display: flex; justify-content: space-between; align-items: center; }
        header h1 { margin: 0; font-weight: 700; }
        nav { display: flex; border-bottom: 2px solid #ddd; background: white; }
        nav button {
            flex: 1; padding: 15px; border: none; background: #eee; cursor: pointer; font-weight: 600;
            transition: background-color 0.3s ease;
        }
        nav button.active, nav button:hover {
            background: #0e838f; color: white; box-shadow: 0 4px 10px rgba(14,131,143,.5);
        }
        main { padding: 20px; }
        .tab-content { display: none; animation: fadeIn 0.5s ease forwards; }
        .tab-content.active { display: block; }
        @keyframes fadeIn {
            from {opacity:0; transform: translateY(20px);}
            to {opacity:1; transform: translateY(0);}
        }

        /* Widget layout */
        #widgetContainer {
            display: grid;
            grid-template-columns: repeat(auto-fill,minmax(220px,1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .widget {
            background: white;
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 3px 12px rgba(0,0,0,0.1);
            position: relative;
            transition: transform 0.2s ease;
        }
        .widget:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(14,131,143,0.4);
        }
        .widget .closeBtn {
            position: absolute;
            top: 8px; right: 8px;
            background: #e74c3c;
            border: none;
            border-radius: 50%;
            width: 22px; height: 22px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
        }
        .widget .closeBtn:hover {
            opacity: 1;
        }

        /* buttons */
        .btn-group button {
            padding: 8px 15px;
            margin: 0 3px 10px 0;
            border: none;
            background: #ddd;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .btn-group button.active, .btn-group button:hover {
            background: #0e838f;
            color: white;
        }

        /* check box */
        select {
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid #ccc;
            margin-bottom: 10px;
        }

        #sensorDataChart {
            width: 100% !important;
            max-width: 800px;
            height: auto !important;
            aspect-ratio: 2/1;
            display: block;
            margin: 0 auto;
        }
        @media (max-width: 600px) {
            main {
                padding: 5px;
            }
            #sensorDataChart {
                max-width: 100vw;
                height: auto !important;
            }
        }

        /* Login Form Styles */
        #loginSection, #registrationSection {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            padding: 20px;
        }
        .login-container {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 360px;
            text-align: center;
        }
        .login-container h2 {
            color: #0e838f;
            margin-bottom: 20px;
        }
        .login-container input[type="text"],
        .login-container input[type="password"] {
            width: calc(100% - 20px);
            padding: 10px;
            margin-bottom: 15px;
            border: 1px solid #ccc;
            border-radius: 6px;
            box-sizing: border-box;
        }
        .login-container button {
            width: 100%;
            padding: 12px;
            background: #0e838f;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
        }
        .login-container button:hover {
            background: #0c707a;
        }
        #loginError, #registrationError {
            color: red;
            margin-top: 10px;
            font-size: 0.9em;
        }
        #logoutButton {
            padding: 8px 15px;
            background-color: #e74c3c;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color 0.3s ease;
        }
        #logoutButton:hover {
            background-color: #c0392b;
        }
        .form-switch-link {
            display: block;
            margin-top: 15px;
            color: #0e838f;
            text-decoration: none;
            font-size: 0.9em;
        }
        .form-switch-link:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>

<div id="loginSection" style="display:none;">
    <div class="login-container">
        <h2>Dashboard Login</h2>
        <form id="loginForm">
            <input type="text" id="username" placeholder="Username" required />
            <input type="password" id="password" placeholder="Password" required />
            <button type="submit">Login</button>
            <p id="loginError" style="display:none;"></p>
        </form>
        <a href="#" id="switchToRegister" class="form-switch-link">Don't have an account? Register</a>
    </div>
</div>

<div id="registrationSection" style="display:none;">
    <div class="login-container">
        <h2>Create Account</h2>
        <form id="registrationForm">
            <input type="text" id="regUsername" placeholder="Username" required />
            <input type="password" id="regPassword" placeholder="Password" required />
            <input type="password" id="regConfirmPassword" placeholder="Confirm Password" required />
            <button type="submit">Register</button>
            <p id="registrationError" style="display:none;"></p>
        </form>
        <a href="#" id="switchToLogin" class="form-switch-link">Already have an account? Login</a>
    </div>
</div>

<div id="dashboardSection" style="display:none;">
    <header>
        <h1>ðŸŒŸ EEE4464 IoT Dashboard</h1>
        <button id="logoutButton">Logout</button>
    </header>

    <nav>
        <button class="tabBtn active" data-tab="dashboard">Dashboard</button>
        <button class="tabBtn" data-tab="widgets">Widgets</button>
        <button class="tabBtn" data-tab="settings">Settings</button>
        <button class="tabBtn" data-tab="test">Test</button>
    </nav>

    <main>
        <!-- Dashboard Tab -->
        <section id="dashboard" class="tab-content active">
            <div style="margin:10px 0;">
                <label><input type="checkbox" id="autoRefreshCheckbox" /> Auto Refresh</label>
                <input type="number" id="autoRefreshInterval" value="1" min="1" style="width:60px;" /> seconds
            </div>
            <div>
                <label>Select Device:</label><br />
                <select id="deviceSelect"><option>Loading...</option></select>
            </div>
            <div>
                <label>Select Sensors (multiple):</label><br />
                <select id="sensorSelect" multiple size="5"></select>
            </div>
            <div class="btn-group" id="timeRangeButtons">
                <button data-range="hour" class="active">Hour</button>
                <button data-range="day">Day</button>
                <button data-range="week">Week</button>
                <button data-range="month">Month</button>
                <button data-range="year">Year</button>
            </div>
            <div>
                <label>Select Chart Type:</label><br />
                <select id="chartTypeSelect">
                    <option value="line" selected>Line</option>
                    <option value="bar">Bar</option>
                    <option value="pie">Pie</option>
                    <option value="doughnut">Doughnut</option>
                    <option value="radar">Radar</option>
                </select>
            </div>
            <canvas id="sensorDataChart" width="800" height="400" style="max-width: 800px; height: 400px;"></canvas>
        </section>
         <div id="mqttWidgetModal" style="display:none; position:fixed; top:0; left:0; width:100vw; height:100vh; background:rgba(0,0,0,0.3); align-items:center; justify-content:center; z-index:1000;">
                        <div style="background:white; padding:20px; border-radius:10px; min-width:300px;">
                            <h3>Add MQTT Widget</h3>
                            <input id="mqttBrokerUrl" placeholder="Broker URL(wss://url:port)" style="width:100%; margin-bottom:8px;" />
                            <input id="mqttTopic" placeholder="Topic" style="width:100%; margin-bottom:8px;" />
                            <input id="mqttAccount" placeholder="Account" style="width:100%; margin-bottom:8px;" />
                            <input id="mqttPassword" placeholder="Password" type="password" style="width:100%; margin-bottom:8px;" />
                            <button id="saveMqttWidgetBtn">Connect & Save</button>
                            <button id="cancelMqttWidgetBtn" style="margin-left:10px;">Cancel</button>
                        </div>
                    </div>
        <!-- Widgets Tab -->
        <section id="widgets" class="tab-content">

            <button id="addWidgetBtn">Add Status Widget</button>
            <button id="addMqttWidgetBtn" style="margin-bottom:10px;">Add MQTT Widget</button>

            <div id="mqttWidgetsContainer"></div>
            <div id="widgetContainer"></div>

        </section>

        <!-- Settings Tab -->
        <section id="settings" class="tab-content">
            <h2>User Settings</h2>
            <p>Current settings are saved in browser <code>localStorage</code> and will not sync across devices.</p>
            <label>Default Time Range:</label>
            <select id="defaultTimeRangeSelect">
                <option value="hour">Hour</option>
                <option value="day">Day</option>
                <option value="week">Week</option>
                <option value="month">Month</option>
                <option value="year">Year</option>
            </select>
            <br/>
            <label>Default Chart Type:</label>
            <select id="defaultChartTypeSelect">
                <option value="line">Line</option>
                <option value="bar">Bar</option>
                <option value="pie">Pie</option>
                <option value="doughnut">Doughnut</option>
                <option value="radar">Radar</option>
            </select>
            <br/><br/>
            <button id="saveSettingsBtn">Save Settings</button>
            
            <!-- Password Change Section -->
            <div style="margin-top: 30px; border-top: 1px solid #ddd; padding-top: 20px;">
                <h3>Change Password</h3>
                <div class="login-container" style="background: #f9f9f9; box-shadow: 0 2px 10px rgba(0,0,0,0.05);">
                    <form id="passwordChangeForm">
                        <input type="password" id="currentPassword" placeholder="Current Password" required />
                        <input type="password" id="newPassword" placeholder="New Password" required />
                        <input type="password" id="confirmNewPassword" placeholder="Confirm New Password" required />
                        <button type="submit" style="background-color: #0e838f;">Change Password</button>
                        <p id="passwordChangeError" style="display:none; color:red; margin-top:10px;"></p>
                        <p id="passwordChangeSuccess" style="display:none; color:green; margin-top:10px;"></p>
                    </form>
                </div>
            </div>
        </section>

        <!-- Test Tab -->
        <section id="test" class="tab-content">
            <h2>Test Add Data</h2>
            <div style="margin-bottom:10px;">
                <label>Test Devices:</label>
                <div id="testDeviceList"></div>
            </div>
            <div style="margin-bottom:10px;">
                <label>Test Sensors:</label>
                <div id="testSensorList"></div>
            </div>
            <button id="btnAddDevice">Add Device</button>
            <button id="btnAddSensor">Add Sensor (add device first)</button>
            <button id="btnAddControl">Add Control (add sensor first)</button>
            <button id="btnAddSensorData">Add Sensor Data (add sensor first)</button>
            <button id="btnAddAll">Add All Test Data</button>
            <div style="margin-top:10px;">
                <button id="btnTestDelete">Test Delete</button>
                <span id="lastDeviceInfo" style="margin-left:10px;color:#0e838f;font-weight:bold;"></span>
            </div>
            
            <!-- New section for device ID management -->
            <div style="margin-top:20px; border-top:1px solid #ddd; padding-top:15px;">
                <h3>Manage Device IDs</h3>
                <div style="margin-bottom:10px;">
                    <input type="text" id="deviceIdInput" placeholder="Device ID (3-20 digits)" 
                           style="padding:8px; border-radius:4px; width:200px; margin-right:10px;"
                           pattern="[0-9]{3,20}" title="Enter 3-20 digits only">
                    <br/>
                    <br/>
                    <button id="btnAddDeviceToUser" style="background-color:#28a745; color:white; padding:8px 15px; border:none; border-radius:4px; cursor:pointer; margin-right:10px;">Add to Account</button>
                    <button id="btnRemoveDeviceFromUser" style="background-color:#dc3545; color:white; padding:8px 15px; border:none; border-radius:4px; cursor:pointer;">Remove from Account</button>
                </div>
                <div id="deviceManagementResult" style="margin-top:10px; font-weight:bold;"></div>
                <div style="margin-top:10px;">
                    <p>Your current device IDs: <span id="userDevicesList">Loading...</span></p>
                </div>
            </div>
        </section>
    </main>
</div>
<script>

    // --- variables ---
    const deviceSelect = document.getElementById('deviceSelect');
    const sensorSelect = document.getElementById('sensorSelect');
    const chartCtx = document.getElementById('sensorDataChart');
    const timeRangeButtons = document.getElementById('timeRangeButtons');
    const chartTypeSelect = document.getElementById('chartTypeSelect');
    const defaultTimeRangeSelect = document.getElementById('defaultTimeRangeSelect');
    const defaultChartTypeSelect = document.getElementById('defaultChartTypeSelect');
    const saveSettingsBtn = document.getElementById('saveSettingsBtn');
    const autoRefreshCheckbox = document.getElementById('autoRefreshCheckbox');
    const autoRefreshIntervalInput = document.getElementById('autoRefreshInterval');
    const addWidgetBtn = document.getElementById('addWidgetBtn');
    const widgetContainer = document.getElementById('widgetContainer');
    const tabs = document.querySelectorAll('.tabBtn');
    const contents = document.querySelectorAll('.tab-content');
    let currentChart = null;
    let updating = false;
    // remember each line's color
    let lineColors = {};

    let selectedDeviceId = localStorage.getItem('iot-dashboard-deviceId') || null;
    let selectedSensorIds = localStorage.getItem('iot-dashboard-sensorId')?.split(',') || [];
    let selectedTimeRange = localStorage.getItem('iot-dashboard-timeRange') || 'hour';
    let selectedChartType = localStorage.getItem('iot-dashboard-chartType') || 'line';
    let lastMessageTimestamp = Math.floor(Date.now() / 1000);

    // chart
    let autoRefreshTimer = null;
    let chartDataCache = []; // all sensor data cache
    let chartLastTimestamp = 0;

    // local storage variables
    let lastDeviceId = localStorage.getItem('lastDeviceId') || null;
    let lastControlId = localStorage.getItem('lastControlId') || null;
    let lastSensorId = localStorage.getItem('lastSensorId') || null;
    let lastSensorDataId = localStorage.getItem('lastSensorDataId') || null;

    // User session data
    let currentUser = null;
    let messageCheckInterval = null; // Track message check interval

    let mqttWidgets = JSON.parse(localStorage.getItem('mqttWidgets') || '[]');
    let mqttClients = [];

    function renderMqttWidgets() {
    const container = document.getElementById('mqttWidgetsContainer');
    container.innerHTML = '';
    mqttWidgets.forEach((w, idx) => {
        let status;
        try {
            status = JSON.parse(w.statusJson);
        } catch {
            status = { error: 'Invalid JSON' };
        }
        const div = document.createElement('div');
        div.className = 'widget';
        div.innerHTML = `
            <button class="closeBtn" title="Remove">&times;</button>
            <h4>MQTT Widget</h4>
<!--            <div>Broker: ${w.brokerUrl}</div>-->
            <div>Topic: ${w.topic}</div>
            <div>Status: ${status.connected ? 'Connected' : 'Disconnected'}</div>
            <div>Last Message: ${status.lastMessage || status.error || ''}</div>
        `;
        div.querySelector('.closeBtn').onclick = () => {
            // Disconnect client if exists
            if (mqttClients[idx]) {
                mqttClients[idx].end(true);
                mqttClients[idx] = null;
            }
            mqttWidgets.splice(idx, 1);
            localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
            renderMqttWidgets();
        };
        container.appendChild(div);
    });
}

    function getLineColor(label, idx) {
        if (!lineColors[label]) {
            const baseColors = [
                '#0e838f', '#8a2be2', '#ff7f50', '#ffdc34', '#0ecb81', '#c74e4e', '#bc7af9',
                '#f08a5d', '#f9ed69', '#3ec1d3', '#ffb6b9', '#283c63'
            ];
            lineColors[label] = baseColors[idx % baseColors.length];
        }
        return lineColors[label];
    }

    // init dataset
    const datasets = chartDataCache.map((d, i) => ({
        label: `${d.field} (Sensor:${d.sensorId})`,
        data: d.points,
        borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
        backgroundColor: 'transparent',
        fill: false,
        tension: 0.2,
        pointRadius: 2
    }));
    function startAutoRefresh() {
        if (autoRefreshTimer) clearInterval(autoRefreshTimer);
        if (!autoRefreshCheckbox.checked) return;
        autoRefreshTimer = setInterval(() => {
            fetchNewSensorData();


            mqttWidgets.forEach(w => {
                // Simulate a new message
                w.statusJson = JSON.stringify({
                    connected: true,
                    lastMessage: 'Random: ' + Math.random().toString(36).substring(2, 8)
                });
            });
            localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
            renderMqttWidgets();
        }, Number(autoRefreshIntervalInput.value) * 1000);


    }

    // Function to start message checking interval
    function startMessageChecker() {
        if (messageCheckInterval) clearInterval(messageCheckInterval); // Prevent duplicate intervals
        messageCheckInterval = setInterval(checkNewMessages, 3000);
        console.log('Message checker started');
    }

    // Function to stop message checking interval
    function stopMessageChecker() {
        if (messageCheckInterval) {
            clearInterval(messageCheckInterval);
            messageCheckInterval = null;
            console.log('Message checker stopped');
        }
    }

    // --- init ---
    async function initDashboard() {
        console.log('Initializing dashboard...');
        loadSettings();
        setupEventListeners(); // Original event listeners  this should be called after login and brefore loading devices
        await loadDevices(); // This will now use user-specific devices
        renderMqttWidgets();
        startMessageChecker(); // Start message checker after login

    }

    // --- Login and Session Management ---
    async function checkLoginState() {
        const token = localStorage.getItem('sessionToken');
        const userDataString = localStorage.getItem('userData');

        if (token && userDataString) {
            currentUser = JSON.parse(userDataString);
            document.getElementById('loginSection').style.display = 'none';
            document.getElementById('registrationSection').style.display = 'none';
            document.getElementById('dashboardSection').style.display = 'block';
            await initDashboard();
        } else {
            showLoginForm(); // Default to login form
            document.getElementById('dashboardSection').style.display = 'none';
            currentUser = null;
        }
    }

    function showLoginForm() {
        document.getElementById('loginSection').style.display = 'flex';
        document.getElementById('registrationSection').style.display = 'none';
    }

    function showRegistrationForm() {
        document.getElementById('loginSection').style.display = 'none';
        document.getElementById('registrationSection').style.display = 'flex';
    }


    document.addEventListener('DOMContentLoaded', () => {
        checkLoginState();

        const loginForm = document.getElementById('loginForm');
        const registrationForm = document.getElementById('registrationForm');
        const switchToRegisterLink = document.getElementById('switchToRegister');
        const switchToLoginLink = document.getElementById('switchToLogin');

        if (switchToRegisterLink) {
            switchToRegisterLink.addEventListener('click', (e) => {
                e.preventDefault();
                showRegistrationForm();
            });
        }

        if (switchToLoginLink) {
            switchToLoginLink.addEventListener('click', (e) => {
                e.preventDefault();
                showLoginForm();
            });
        }


        if (loginForm) {
            loginForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('username').value;
                const password = document.getElementById('password').value;
                const loginError = document.getElementById('loginError');
                loginError.style.display = 'none';

                try {
                    const response = await fetch('/api/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            localStorage.setItem('sessionToken', data.token);
                            localStorage.setItem('userData', JSON.stringify({ username: data.username, devices: data.devices }));
                            await checkLoginState();
                        } else {
                            loginError.textContent = data.message || 'Login failed.';
                            loginError.style.display = 'block';
                        }
                    } else {
                        const errorData = await response.json();
                        loginError.textContent = errorData.message || `Error: ${response.status}`;
                        loginError.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Login request failed:', error);
                    loginError.textContent = 'Login request failed. Check console.';
                    loginError.style.display = 'block';
                }
            });
        }
        
        if (registrationForm) {
            registrationForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const username = document.getElementById('regUsername').value;
                const password = document.getElementById('regPassword').value;
                const confirmPassword = document.getElementById('regConfirmPassword').value;
                const registrationError = document.getElementById('registrationError');
                registrationError.style.display = 'none';

                if (password !== confirmPassword) {
                    registrationError.textContent = 'Passwords do not match.';
                    registrationError.style.display = 'block';
                    return;
                }

                // Basic password policy (example: at least 6 characters)
                if (password.length < 6) {
                    registrationError.textContent = 'Password must be at least 6 characters long.';
                    registrationError.style.display = 'block';
                    return;
                }
                // Basic username policy (example: at least 3 characters)
                if (username.length < 3) {
                    registrationError.textContent = 'Username must be at least 3 characters long.';
                    registrationError.style.display = 'block';
                    return;
                }


                try {
                    const response = await fetch('/api/register', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username, password })
                    });

                    const data = await response.json();

                    if (response.ok && data.success) {
                        alert('Registration successful! Please login.'); // Or show a success message
                        showLoginForm(); // Switch to login form
                        document.getElementById('registrationForm').reset(); // Reset registration form
                    } else {
                        registrationError.textContent = data.message || 'Registration failed.';
                        registrationError.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Registration request failed:', error);
                    registrationError.textContent = 'Registration request failed. Check console.';
                    registrationError.style.display = 'block';
                }
            });
        }

        const logoutButton = document.getElementById('logoutButton');
        if (logoutButton) {
            logoutButton.addEventListener('click', () => {
                localStorage.removeItem('sessionToken');
                localStorage.removeItem('userData');
                stopMessageChecker(); // Stop message checker on logout
                // Clear sensitive cached data if any
                chartDataCache = [];
                chartLastTimestamp = 0;
                selectedDeviceId = null;
                selectedSensorIds = [];
                if (currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
                // Reset UI elements that might hold old data
                deviceSelect.innerHTML = '<option>Loading...</option>';
                sensorSelect.innerHTML = '';

                checkLoginState();
            });
        }

        const passwordChangeForm = document.getElementById('passwordChangeForm');
        
        if (passwordChangeForm) {
            passwordChangeForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const currentPassword = document.getElementById('currentPassword').value;
                const newPassword = document.getElementById('newPassword').value;
                const confirmNewPassword = document.getElementById('confirmNewPassword').value;
                const passwordChangeError = document.getElementById('passwordChangeError');
                const passwordChangeSuccess = document.getElementById('passwordChangeSuccess');
                
                // Reset messages
                passwordChangeError.style.display = 'none';
                passwordChangeSuccess.style.display = 'none';
                
                // Check if user is logged in
                if (!currentUser || !currentUser.username) {
                    passwordChangeError.textContent = 'You must be logged in to change your password.';
                    passwordChangeError.style.display = 'block';
                    return;
                }
                
                // Check if passwords match
                if (newPassword !== confirmNewPassword) {
                    passwordChangeError.textContent = 'New passwords do not match.';
                    passwordChangeError.style.display = 'block';
                    return;
                }
                
                // Basic password policy (at least 6 characters)
                if (newPassword.length < 6) {
                    passwordChangeError.textContent = 'New password must be at least 6 characters long.';
                    passwordChangeError.style.display = 'block';
                    return;
                }
                
                try {
                    const response = await fetch('/api/change-password', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            username: currentUser.username,
                            currentPassword,
                            newPassword
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (response.ok && data.success) {
                        passwordChangeSuccess.textContent = data.message || 'Password changed successfully.';
                        passwordChangeSuccess.style.display = 'block';
                        document.getElementById('passwordChangeForm').reset();
                    } else {
                        passwordChangeError.textContent = data.message || 'Failed to change password.';
                        passwordChangeError.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Password change request failed:', error);
                    passwordChangeError.textContent = 'Password change request failed. Check console.';
                    passwordChangeError.style.display = 'block';
                }
            });
        }



        mqttWidgets.forEach((w, idx) => {

            const client = mqtts.connect(w.brokerUrl, {
                username: w.account,
                password: w.password
            });
            mqttClients[idx] = client;
            client.on('connect', () => {
                w.statusJson = JSON.stringify({ connected: true, lastMessage: '' });
                localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                renderMqttWidgets();
                client.subscribe(w.topic, (err) => {
                    if (err) {
                        w.statusJson = JSON.stringify({ connected: false, error: 'Subscribe failed' });
                        localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                        renderMqttWidgets();
                    }
                });
            });
            client.on('message', (t, message) => {
                if (t === w.topic) {
                    w.statusJson = JSON.stringify({ connected: true, lastMessage: message.toString() });
                    localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                    renderMqttWidgets();
                }
            });
            client.on('error', (err) => {
                w.statusJson = JSON.stringify({ connected: false, error: err.message });
                localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                renderMqttWidgets();
            });
        });
        renderMqttWidgets();
    });

    // --- load devices ---
    async function loadDevices() {
        const userDataString = localStorage.getItem('userData');
        if (!userDataString) {
            console.error("User data not found for loading devices.");
            deviceSelect.innerHTML = '<option value="">--Login Required--</option>';
            return;
        }
        const userData = JSON.parse(userDataString);
        const allowedDeviceIds = userData.devices; // Expected: array of device_ids

        if (!allowedDeviceIds || allowedDeviceIds.length === 0) {
            deviceSelect.innerHTML = '<option value="">--No Devices Assigned--</option>';
            selectedDeviceId = null; // Ensure selectedDeviceId is cleared
            await loadSensors(null); // Clear sensors
            await loadAndRenderSensorData(); // Clear chart

            return;
        }

        const deviceIdsQueryParam = allowedDeviceIds.map(id => encodeURIComponent(id)).join(',');
        // Fetch only the devices assigned to the user
        const res = await fetch(`/api/device?device_ids=${deviceIdsQueryParam}&limit=${allowedDeviceIds.length}`);
        if (!res.ok) {
            console.error("Failed to load user devices:", await res.text());
            deviceSelect.innerHTML = '<option value="">--Error Loading Devices--</option>';
            return;
        }
        const userDevices = await res.json();

        // @ts-ignore
        deviceSelect.innerHTML = '<option value="">--Please Select Device--</option>' + userDevices.map(function(d) {
            return '<option value="' + d.device_id + '">' + d.device_name +'-'+d.device_type +'-'+d.device_id +'</option>';
        }).join('');
        
        if (userDevices.length > 0) {
            let lastSelectedDeviceId = localStorage.getItem('iot-dashboard-deviceId');
            // Ensure the last selected device is in the allowed list
            const isValidLastDevice = lastSelectedDeviceId && userDevices.some(d => d.device_id.toString() === lastSelectedDeviceId);

            if (isValidLastDevice) {
                deviceSelect.value = lastSelectedDeviceId;
                selectedDeviceId = lastSelectedDeviceId;
            } else {
                deviceSelect.selectedIndex = 0; // Or prompt to select
                selectedDeviceId = null;
                localStorage.removeItem('iot-dashboard-deviceId'); // Clear invalid stored ID
            }
        } else {
            deviceSelect.selectedIndex = 0;
            selectedDeviceId = null;
            localStorage.removeItem('iot-dashboard-deviceId');
        }
        // Trigger change to load sensors for the selected device (if any)
        console.log("Loaded user devices:", userDevices);
        if (selectedDeviceId) {
             console.log("Selected device ID:", selectedDeviceId);
             deviceSelect.dispatchEvent(new Event('change', {bubbles: true}));
        } else {
            await loadSensors(null);
            await loadAndRenderSensorData();
        }
    }

    // --- loading sensors ---
    async function loadSensors(deviceId) {
        if (!deviceId) {
            sensorSelect.innerHTML = '';
            return;
        }
        const res = await fetch(`/api/sensors?device_id=${deviceId}&limit=100`);
        const sensors = await res.json();
        sensorSelect.innerHTML = sensors.length ? sensors.map(function(s) {
            return '<option value="' + s.sensor_id + '">' + s.sensor_name + ' (' + (s.sensor_type || 'unknown') + '-' + s.sensor_id + ')</option>';
        }).join('') : '<option>No sensor</option>';
        console.log("Loaded sensors for device:", deviceId, sensors);
        if (sensorSelect.children.length > 0) {
            const sensorIds = localStorage.getItem('iot-dashboard-sensorId');
            if (sensorIds) {
                setTimeout(() => {
                    const ids = sensorIds.split(',').map(id => id.trim());
                    Array.from(sensorSelect.options).forEach(opt => {
                        opt.selected = ids.includes(opt.value);
                    })
                    sensorSelect.dispatchEvent(new Event('change', {bubbles: true}));
                },0);
            } else {
                sensorSelect.selectedIndex = -1;
                selectedSensorIds = [];
            }
        } else {
            selectedSensorIds = [];
        }
    }

    // --- load and render trending data ---
    async function loadAndRenderSensorData() {
        if (updating) return;
        updating = true;
        if (!selectedSensorIds.length) {
            renderChart([]);
            chartDataCache = [];
            chartLastTimestamp = 0;
            updating = false;
            return;
        }
        const now = Math.floor(Date.now() / 1000);
        let start;
        switch(selectedTimeRange) {
            case 'hour': start = now - 3600; break;
            case 'day': start = now - 86400; break;
            case 'week': start = now - 86400*7; break;
            case 'month': start = now - 86400*30; break;
            case 'year': start = now - 86400*365; break;
            default: start = now - 3600;
        }

        chartDataCache = [];
        chartLastTimestamp = 0;
        const validSensorIds = selectedSensorIds.filter(id => id.trim() !== "");
        if (validSensorIds.length === 0) {
            renderChart([]);
            updating = false;
            console.log("No valid sensors selected for data loading.");
            return;
        }
        await Promise.all(selectedSensorIds.map(async (sensorId) => {
            const resp = await fetch(`/api/sensor_data?sensor_id=${sensorId}&start=${start}&end=${now}&limit=1000`);
            const data = await resp.json();
            if (!data.length) return;
            const allFields = Object.keys(JSON.parse(data[0].data));
            allFields.forEach(field => {
                const points = data.map(d => ({
                    x: d.timestamp * 1000,
                    y: parseFloat(JSON.parse(d.data)[field])
                })).reverse();
                chartDataCache.push({
                    sensorId,
                    field,
                    points
                });
            });
            chartLastTimestamp = Math.max(chartLastTimestamp, ...data.map(d => d.timestamp * 1000));
        }));

        const datasets = chartDataCache.map((d,i) => ({
            label: `${d.field} (Sensor:${d.sensorId})`,
            data: d.points,
            borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
            backgroundColor: 'transparent',
            fill: false,
            tension: 0.2,
            pointRadius: 2
        }));

        renderChart(datasets);
        updating = false;
    }

    async function fetchNewSensorData() {
        if (!selectedSensorIds.length || !chartLastTimestamp) return;
        // console.log(`Fetching new sensor data... (${new Date().toISOString()})`);
        // console.log(`Number of sensors to check: ${chartDataCache.length}`);
        
        const now = Math.floor(Date.now() / 1000);
        let hasUpdate = false;
        
        // Group chartDataCache entries by sensorId to avoid redundant API calls
        const sensorGroups = {};
        chartDataCache.forEach((entry, index) => {
            if (!sensorGroups[entry.sensorId]) {
                sensorGroups[entry.sensorId] = {
                    sensorId: entry.sensorId,
                    fields: [],
                    cacheIndices: []
                };
            }
            sensorGroups[entry.sensorId].fields.push(entry.field);
            sensorGroups[entry.sensorId].cacheIndices.push(index);
        });
        
        // console.log(`Optimized: Making ${Object.keys(sensorGroups).length} API calls instead of ${chartDataCache.length}`);
        
        // Now make one API call per sensor rather than per field
        await Promise.all(Object.values(sensorGroups).map(async (group) => {
            const startTime = Math.floor(chartLastTimestamp/1000) + 1;
            // console.log(`Fetching data for sensor ${group.sensorId}, fields: ${group.fields.join(', ')}, start: ${startTime}, end: ${now}`);
            
            const resp = await fetch(`/api/sensor_data?sensor_id=${group.sensorId}&start=${startTime}&end=${now}&limit=100`);
            const data = await resp.json();
            
            if (!data.length) {
                // console.log(`No new data found for sensor ${group.sensorId}`);
                return;
            }
            
            // console.log(`Found ${data.length} new data points for sensor ${group.sensorId}`);

            // Update all fields from this sensor data
            group.cacheIndices.forEach((cacheIndex) => {
                const entry = chartDataCache[cacheIndex];
                const field = entry.field;
                const newPoints = [];
                
                data.forEach(row => {
                    try {
                        const parsedData = JSON.parse(row.data);
                        const val = parsedData[field];
                        if (val !== undefined) {
                            newPoints.push({
                                x: row.timestamp * 1000,
                                y: parseFloat(val)
                            });
                        }
                    } catch (err) {
                        console.warn(`Error parsing data for sensor ${group.sensorId}, field ${field}:`, err);
                    }
                });
                
                if (newPoints.length) {
                    // console.log(`Adding ${newPoints.length} valid points for field ${field}`);
                    entry.points = entry.points.concat(newPoints);
                    hasUpdate = true;
                } else {
                    // console.log(`No valid points found for field ${field}`);
                }
            });
        }));

        if (hasUpdate) {
            // console.log(`Updating chart with new data...`);
            chartLastTimestamp = Math.max(...chartDataCache.map(d => d.points.length ? d.points[d.points.length-1].x : 0));
            const datasets = chartDataCache.map((d,i) => ({
                label:`${d.field} (Sensor:${d.sensorId})`,
                data: d.points,
                borderColor:  getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2,
                pointRadius: 2
            }));
            renderChart(datasets);
        } else {
            // console.log(`No updates needed for chart.`);
        }
    }

    function renderChart(datasets) {
        if (currentChart) {
            currentChart.destroy();
            currentChart = null;
        }
        const timeUnitMap = {
            hour: 'minute',
            day: 'hour',
            week: 'day',
            month: 'day',
            year: 'month'
        };

        let fitLines = [];
        datasets.forEach((ds, i) => {
            if (ds.data.length > 1) {
                const {k, b} = linearFit(ds.data);
                const x0 = ds.data[0].x;
                const x1 = ds.data[ds.data.length-1].x;
                const fitData = [
                    {x: x0, y: k*0 + b},
                    {x: x1, y: k*(ds.data.length-1) + b}
                ];
                fitLines.push({
                    label: `${ds.label} fit`,
                    data: [
                        {x: x0, y: k*0 + b},
                        {x: x1, y: k*(ds.data.length-1) + b}
                    ],
                    borderColor: ds.borderColor,
                    borderDash: [6, 4],
                    borderWidth: 2,
                    backgroundColor: 'transparent',
                    fill: false,
                    tension: 0,
                    pointRadius: 0,
                    showLine: true,
                    order: 99,
                    fitFormula: `y = ${k.toFixed(2)}x + ${b.toFixed(2)}`,
                    _fitColor: ds.borderColor
                });
            }
        });

        let allDatasets = [...datasets];
        fitLines.forEach(fit => {
            allDatasets.push({
                label: fit.label,
                data: fit.data,
                borderColor: fit.borderColor,
                borderDash: fit.borderDash,
                borderWidth: fit.borderWidth,
                backgroundColor: fit.backgroundColor,
                fill: fit.fill,
                tension: fit.tension,
                pointRadius: fit.pointRadius,
                showLine: fit.showLine,
                order: fit.order,
                fitFormula: fit.fitFormula,
                _fitColor: fit._fitColor
            });
        });

        let chartType = selectedChartType;
        if (chartType === 'pie' || chartType === 'doughnut') {
            const first = datasets[0];
            if (!first) return;
            currentChart = new Chart(chartCtx, {
                type: chartType,
                data: {
                    labels: first.data.map(p => new Date(p.x).toLocaleString()),
                    datasets: [{
                        label: first.label,
                        data: first.data.map(p => p.y),
                        backgroundColor: pieColors(first.data.length)
                    }]
                },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true
                            }
                        }
                    }
                }
            });
        } else {
            currentChart = new Chart(chartCtx, {
                type: chartType,
                data: { datasets: allDatasets },
                options: {
                    responsive: false,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                usePointStyle: true
                            },
                            onClick: function(e, legendItem, legend) {
                                const index = legendItem.datasetIndex;
                                const ci = legend.chart;
                                const meta = ci.getDatasetMeta(index);
                                if (meta.hidden === null) {
                                    meta.hidden = !ci.data.datasets[index].hidden;
                                } else {
                                    meta.hidden = null;
                                }
                                ci.update();
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            time: { unit: timeUnitMap[selectedTimeRange] || 'day' },
                            title: { display: true, text: 'time' },
                            ticks: { autoSkip: true, maxTicksLimit: 10 }
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'value' }
                        }
                    }
                },
                plugins: [{
                    id: 'fitFormulaLabel',
                    afterDraw(chart) {
                        const ctx = chart.ctx;
                        let y = 30;
                        chart.data.datasets.forEach((ds, i) => {
                            if (ds.fitFormula) {
                                ctx.save();
                                ctx.font = 'bold 13px Segoe UI';
                                ctx.fillStyle = ds._fitColor || '#0e838f';
                                ctx.textBaseline = 'top';
                                ctx.fillText(ds.fitFormula, 60, y);
                                y += 20;
                                ctx.restore();
                            }
                        });
                    }
                }]
            });
        }
        showChartStats(datasets, fitLines);
    }

    function showChartStats(datasets, fitLines) {
        let statsHtml = '';
        if (!datasets || !datasets.length) {
            document.getElementById('chartStats')?.remove();
            return;
        }
        statsHtml += `<div style="margin-top:15px;" id="chartStats"><h3>Statistical analysis</h3>`;
        statsHtml += `<table style="border-collapse:collapse;width:100%;background:#fff;border-radius:8px;box-shadow:0 2px 8px #eee;">`;
        statsHtml += `<tr style="background:#0e838f;color:#fff;"><th>Name</th><th>Mean</th><th>Max</th><th>Min</th><th>Trend</th></tr>`;
        datasets.forEach(ds => {
            const values = ds.data.map(p => p.y);
            if (!values.length) return;
            const avg = (values.reduce((a,b)=>a+b,0)/values.length).toFixed(2);
            const max = Math.max(...values).toFixed(2);
            const min = Math.min(...values).toFixed(2);
            const trend = values[0] < values[values.length-1] ? 'Increasing' : (values[0] > values[values.length-1] ? 'Decreasing' : 'Stable');
            statsHtml += `<tr>
                <td>${ds.label}</td>
                <td>${avg}</td>
                <td>${max}</td>
                <td>${min}</td>
                <td>${trend}</td>
            </tr>`;
        });
        statsHtml += `</table>`;

        if (fitLines && fitLines.length) {
            statsHtml += `<div style="margin-top:10px;">`;
            fitLines.forEach(fit => {
                statsHtml += `<span style="display:inline-block;margin-right:20px;color:${fit._fitColor};font-weight:bold;">${fit.fitFormula}</span>`;
            });
            statsHtml += `</div>`;
        }
        statsHtml += `</div>`;

        let statsDiv = document.getElementById('chartStats');
        if (!statsDiv) {
            statsDiv = document.createElement('div');
            statsDiv.id = 'chartStats';
            document.getElementById('sensorDataChart').parentNode.appendChild(statsDiv);
        }
        statsDiv.outerHTML = statsHtml;
    }

    function linearFit(points) {
        const n = points.length;
        let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
        for (let i = 0; i < n; i++) {
            const x = i, y = points[i].y;
            sumX += x;
            sumY += y;
            sumXY += x * y;
            sumXX += x * x;
        }
        const k = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX + 1e-8);
        const b = (sumY - k * sumX) / n;
        return {k, b};
    }

    async function loadWidgets() {
        if (!selectedDeviceId) {
            widgetContainer.innerHTML = 'Please select a device first';
            return;
        }
        const res = await fetch(`/api/controls?device_id=${selectedDeviceId}`);
        const controls = await res.json();
        widgets = controls.map(ctrl => {
            if (ctrl.control_type === 'MQTT') {
                try {
                    const mqttData = JSON.parse(ctrl.state);
                    return { ...ctrl, ...mqttData, isMqtt: true };
                } catch {
                    return { ...ctrl, isMqtt: true, error: 'Invalid MQTT JSON' };
                }
            }
            return ctrl;
        });
        renderWidgets();
    }

    function renderWidgets() {
        widgetContainer.innerHTML = '';
        widgets.forEach(w => {
            // if control type is 'MQTT' skip this one
            if(w.control_type === 'MQTT'){
                // TODO: render MQTT widget
                // load the data from control.state JSON data
                // fill this data in 'mqttWidgetModal' and then trigger save action
                const mqttData = JSON.parse(w.state || '{}');

                const brokerUrl = document.getElementById('mqttBrokerUrl').value.trim();
                const topic = document.getElementById('mqttTopic').value.trim();
                const account = document.getElementById('mqttAccount').value.trim();
                const password = document.getElementById('mqttPassword').value.trim();
                brokerUrl.value = mqttData.brokerUrl || brokerUrl;
                topic.value = mqttData.topic || topic;
                account.value = mqttData.account || account;
                password.value = mqttData.password || password;
                console.log(brokerUrl);
                const mqttWidgetModal = document.getElementById('mqttWidgetModal');
                if (!brokerUrl || !topic || !account || !password) {
                    alert('Broker URL, Topic, Account, and Password are required');
                    return;
                }
                const widgetInfo = { brokerUrl, topic, account, password };
                // Create MQTT client
                const client = mqtt.connect(brokerUrl, {
                    username: account,
                    password: password
                });
                const widget = { brokerUrl, topic, account, password, statusJson: JSON.stringify({ connected: false }) };
                mqttWidgets.push(widget);
                mqttClients.push(client);
                localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                renderMqttWidgets();
                client.on('connect', () => {
                    widget.statusJson = JSON.stringify({ connected: true, lastMessage: '' });
                    localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                    renderMqttWidgets();
                    client.subscribe(topic, (err) => {
                        if (err) {
                            widget.statusJson = JSON.stringify({ connected: false, error: 'Subscribe failed' });
                            localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                            renderMqttWidgets();
                        }
                    });
                });

                client.on('message', (t, message) => {
                    if (t === topic) {
                        widget.statusJson = JSON.stringify({ connected: true, lastMessage: message.toString() });
                        localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                        renderMqttWidgets();
                    }
                });

                client.on('error', (err) => {
                    widget.statusJson = JSON.stringify({ connected: false, error: err.message });
                    localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                    renderMqttWidgets();
                });

                document.getElementById('mqttWidgetModal').style.display = 'none';
                document.getElementById('mqttBrokerUrl').value = '';
                document.getElementById('mqttTopic').value = '';
                document.getElementById('mqttAccount').value = '';
                document.getElementById('mqttPassword').value = '';


            }

            const div = document.createElement('div');
            div.className = 'widget';
            div.innerHTML = `
              <button class="closeBtn" data-id="${w.control_id}">Ã—</button>
              <h4>${w.control_name || w.control_type}</h4>
              <p>Staus: <strong>${w.state || 'unknown'}</strong></p>
              <button class="toggleBtn">${w.state === 'on' ? 'OFF' : 'ON'}</button>
            `;
            div.querySelector('.closeBtn').onclick = () => {
                widgets = widgets.filter(x => x.control_id !== w.control_id);
                fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'DELETE'
                }).then(resp => {
                    if (resp.ok) {
                        renderWidgets();
                    } else {
                        alert('Delete failed');
                    }
                });
                renderWidgets();
            };
            div.querySelector('.toggleBtn').onclick = async () => {
                const newState = w.state === 'on' ? 'off' : 'on';

                fetch('/api/messages', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        control_id: w.control_id,
                        state: newState,
                        device_id: w.device_id,
                        from_source: 'web'
                    })
                });

                const resp = await fetch('/api/controls?control_id=' + w.control_id, {
                    method: 'PUT',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({state: newState})
                });
                if (resp.ok) {
                    w.state = newState;
                    renderWidgets();
                } else {
                    alert('Update failed');
                }
            };
            widgetContainer.appendChild(div);
        });
    }

    function setupEventListeners() {
        deviceSelect.addEventListener('change', async () => {
            selectedSensorIds = [];
            console.log('Device changed:', deviceSelect.value);
            selectedDeviceId = deviceSelect.value;
            sensorSelect.selectedIndex = -1;
            await loadSensors(selectedDeviceId);
            await loadWidgets();
            if (localStorage.getItem('iot-dashboard-deviceId') !== selectedDeviceId) {
                localStorage.setItem('iot-dashboard-deviceId', selectedDeviceId);
            }
            await loadAndRenderSensorData();
        });

        sensorSelect.addEventListener('change', () => {
            selectedSensorIds = Array.from(sensorSelect.selectedOptions).map(opt => opt.value);
            if ( localStorage.getItem('iot-dashboard-sensorId') !== selectedSensorIds)
            {localStorage.setItem('iot-dashboard-sensorId', selectedSensorIds);}

            reloadTimeRangeBtn();
            loadAndRenderSensorData();
        });

        timeRangeButtons.querySelectorAll('button').forEach(btn => {
            btn.addEventListener('click', () => {
                timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedTimeRange = btn.dataset.range;
                localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
                loadAndRenderSensorData();
            });
        });

        chartTypeSelect.addEventListener('change', () => {
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            selectedChartType = chartTypeSelect.value;
            const datasets = chartDataCache.map((d,i) => ({
                label: `${d.field} (Sensor:${d.sensorId})`,
                data: d.points,
                borderColor: getLineColor(`${d.field}-${d.sensorId}`, i),
                backgroundColor: 'transparent',
                fill: false,
                tension: 0.2
            }));
            renderChart(datasets);
        });

        saveSettingsBtn.addEventListener('click', () => {
            saveSettingsToLocal();
            alert('Setting saved to localStorage');
        });

        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;

        defaultTimeRangeSelect.addEventListener('change', (e) => {
            selectedTimeRange = e.target.value;
            timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
            const btn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
            if (btn) btn.classList.add('active');
            loadAndRenderSensorData();
        });

        defaultChartTypeSelect.addEventListener('change', (e) => {
            selectedChartType = e.target.value;
            chartTypeSelect.value = selectedChartType;
            loadAndRenderSensorData();
        });

        addWidgetBtn.addEventListener('click', async () => {
            if (!selectedDeviceId) {
                return alert('Please select a device sensor first');
            }
            const sensor_id = sensorSelect.value;
            const name = prompt('Please enter widget name');
            const type = prompt('Please enter type (button/slider/switch)');
            if (!name || !type) return alert('name and type cannot be empty');
            const resp = await fetch('/api/controls', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({control_id:sensor_id,device_id: selectedDeviceId, control_name: name, control_type: type,
                    state: 'off'})
            });
            if (resp.ok) {
                await loadWidgets();
            } else {
                alert('Add widget failed');
            }
        });

        autoRefreshCheckbox.addEventListener('change', startAutoRefresh);

        document.getElementById('btnAddDevice').addEventListener('click', addTestDevice);

        document.getElementById('btnAddControl').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            if (!lastSensorId) {
                lastDeviceId = await addTestSensor();
            }

            await addTestControl(lastDeviceId);
        });

        document.getElementById('btnAddSensor').addEventListener('click', async () => {
            if (!lastDeviceId) {
                lastDeviceId = await addTestDevice();
            }
            await addTestSensor(lastDeviceId);
        });

        document.getElementById('btnAddSensorData').addEventListener('click', async () => {
            if (!lastSensorId) {
                alert('Please add a sensor first');
                return;
            }
            await addTestSensorData(lastSensorId);
        });

        document.getElementById('btnAddAll').addEventListener('click', addTestAll);

        document.getElementById('btnTestDelete').addEventListener('click', async () => {
            const radios = document.querySelectorAll('input[name="testDeviceRadio"]:checked');
            const deviceId = radios.length ? radios[0].value : null;
            if (!deviceId) {
                alert('Pls select Test Device you want to delete');
                return;
            }
            if (!confirm(`Delete device ${deviceId} and all related data?`)) return;

            try {
                await fetch(`/api/controls?device_id=${deviceId}`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async controls => {
                        for (const ctrl of controls) {
                            await fetch(`/api/controls?control_id=${ctrl.control_id}`, { method: 'DELETE' });
                        }
                    });

                await fetch(`/api/sensors?device_id=${deviceId}&limit=100`, { method: 'GET' })
                    .then(res => res.json())
                    .then(async sensors => {
                        for (const sensor of sensors) {
                            await fetch(`/api/sensor_data?sensor_id=${sensor.sensor_id}`, { method: 'GET' })
                                .then(res => {
                                    if (res.ok) {
                                        return res.json();
                                    } else {
                                        throw new Error('Failed to fetch sensor data');
                                    }

                                });
                            await fetch(`/api/sensors?sensor_id=${sensor.sensor_id}`, { method: 'DELETE' });
                        }
                    });

                await fetch(`/api/device?device_id=${deviceId}`, { method: 'DELETE' });

                localStorage.removeItem('lastDeviceId');
                localStorage.removeItem('lastControlId');
                localStorage.removeItem('lastSensorId');
                localStorage.removeItem('lastSensorDataId');

                document.getElementById('lastDeviceInfo').textContent = 'No lastDeviceId';
                loadTestDeviceList();
                alert('Device and related data deleted.');
            } catch (e) {
                alert('Delete failed: ' + e);
            }
        });

        // Add event listeners for device ID management
        const deviceIdInput = document.getElementById('deviceIdInput');
        const btnAddDeviceToUser = document.getElementById('btnAddDeviceToUser');
        const btnRemoveDeviceFromUser = document.getElementById('btnRemoveDeviceFromUser');
        const deviceManagementResult = document.getElementById('deviceManagementResult');

        // Input validation for device ID (numbers only, 3-20 digits)
        deviceIdInput.addEventListener('input', function() {
            this.value = this.value.replace(/[^0-9]/g, '');
            if (this.value.length > 20) {
                this.value = this.value.slice(0, 20);
            }
        });
        
        // Add device ID to user
        btnAddDeviceToUser.addEventListener('click', async () => {
            const deviceId = deviceIdInput.value.trim();
            
            // Input validation
            if (!deviceId || deviceId.length < 3 || deviceId.length > 20 || !/^\d+$/.test(deviceId)) {
                deviceManagementResult.textContent = 'Please enter a valid device ID (3-20 digits)';
                deviceManagementResult.style.color = '#dc3545';
                return;
            }
            
            // Check if user is logged in
            if (!currentUser || !currentUser.username) {
                deviceManagementResult.textContent = 'Please login first';
                deviceManagementResult.style.color = '#dc3545';
                return;
            }
            
            deviceManagementResult.textContent = 'Processing...';
            deviceManagementResult.style.color = '#0e838f';
            
            try {
                const response = await fetch('/api/user/devices/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        username: currentUser.username,
                        device_id: deviceId
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update current user data with the new devices list
                    currentUser.devices = result.devices;
                    localStorage.setItem('userData', JSON.stringify(currentUser));
                    
                    deviceManagementResult.textContent = result.message || 'Device added successfully';
                    deviceManagementResult.style.color = '#28a745';
                    
                    // Clear input field
                    deviceIdInput.value = '';
                    
                    // Refresh device lists
                    updateUserDevicesList();
                    await loadDevices(); // Reload main device dropdown
                } else {
                    deviceManagementResult.textContent = result.message || 'Failed to add device';
                    deviceManagementResult.style.color = '#dc3545';
                }
            } catch (error) {
                console.error('Error adding device:', error);
                deviceManagementResult.textContent = 'An error occurred. Check console for details.';
                deviceManagementResult.style.color = '#dc3545';
            }
        });
        
        // Remove device ID from user
        btnRemoveDeviceFromUser.addEventListener('click', async () => {
            const deviceId = deviceIdInput.value.trim();
            
            // Input validation
            if (!deviceId || !/^\d+$/.test(deviceId)) {
                deviceManagementResult.textContent = 'Please enter a valid device ID';
                deviceManagementResult.style.color = '#dc3545';
                return;
            }
            
            // Check if user is logged in
            if (!currentUser || !currentUser.username) {
                deviceManagementResult.textContent = 'Please login first';
                deviceManagementResult.style.color = '#dc3545';
                return;
            }
            
            deviceManagementResult.textContent = 'Processing...';
            deviceManagementResult.style.color = '#0e838f';
            
            try {
                const response = await fetch('/api/user/devices/remove', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        username: currentUser.username,
                        device_id: deviceId
                    })
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    // Update current user data with the new devices list
                    currentUser.devices = result.devices;
                    localStorage.setItem('userData', JSON.stringify(currentUser));
                    
                    deviceManagementResult.textContent = result.message || 'Device removed successfully';
                    deviceManagementResult.style.color = '#28a745';
                    
                    // Clear input field
                    deviceIdInput.value = '';
                    
                    // Refresh device lists
                    updateUserDevicesList();
                    await loadDevices(); // Reload main device dropdown
                } else {
                    deviceManagementResult.textContent = result.message || 'Failed to remove device';
                    deviceManagementResult.style.color = '#dc3545';
                }
            } catch (error) {
                console.error('Error removing device:', error);
                deviceManagementResult.textContent = 'An error occurred. Check console for details.';
                deviceManagementResult.style.color = '#dc3545';
            }
        });

        // Show/hide modal logic remains unchanged
        document.getElementById('addMqttWidgetBtn').onclick = () => {
            document.getElementById('mqttWidgetModal').style.display = 'flex';
        };
        document.getElementById('cancelMqttWidgetBtn').onclick = () => {
            document.getElementById('mqttWidgetModal').style.display = 'none';
        };

                // Connect and subscribe to MQTT when adding a widget
        document.getElementById('saveMqttWidgetBtn').onclick = () => {
            const brokerUrl = document.getElementById('mqttBrokerUrl').value.trim();
            const topic = document.getElementById('mqttTopic').value.trim();
            const account = document.getElementById('mqttAccount').value.trim();
            const password = document.getElementById('mqttPassword').value.trim();
            if (!brokerUrl || !topic || !account || !password) {
                alert('Broker URL, Topic, Account, and Password are required');
                return;
            }
            const widgetInfo = { brokerUrl, topic, account, password };


            // You may want to generate a unique control_id or let the backend do it
            fetch('/api/controls', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    device_id: selectedDeviceId, // or null if not linked to a device
                    control_type: 'MQTT',
                    control_name: `MQTT: ${topic}`,
                    state: JSON.stringify(widgetInfo),
                    // control_id: `mqtt_${Date.now()}_${Math.random().toString(36).slice(2,8)}`
                    control_id: sensorSelect.value
                })
            });
            // Create MQTT client
            const client = mqtt.connect(brokerUrl, {
                username: account,
                password: password
            });

            const widget = { brokerUrl, topic, account, password, statusJson: JSON.stringify({ connected: false }) };
            mqttWidgets.push(widget);
            mqttClients.push(client);
            localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
            renderMqttWidgets();

            client.on('connect', () => {
                widget.statusJson = JSON.stringify({ connected: true, lastMessage: '' });
                localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                renderMqttWidgets();
                client.subscribe(topic, (err) => {
                    if (err) {
                        widget.statusJson = JSON.stringify({ connected: false, error: 'Subscribe failed' });
                        localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                        renderMqttWidgets();
                    }
                });
            });

            client.on('message', (t, message) => {
                if (t === topic) {
                    widget.statusJson = JSON.stringify({ connected: true, lastMessage: message.toString() });
                    localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                    renderMqttWidgets();
                }
            });

            client.on('error', (err) => {
                widget.statusJson = JSON.stringify({ connected: false, error: err.message });
                localStorage.setItem('mqttWidgets', JSON.stringify(mqttWidgets));
                renderMqttWidgets();
            });

            document.getElementById('mqttWidgetModal').style.display = 'none';
            document.getElementById('mqttBrokerUrl').value = '';
            document.getElementById('mqttTopic').value = '';
            document.getElementById('mqttAccount').value = '';
            document.getElementById('mqttPassword').value = '';
        };

    }

    // Function to update user devices list display
    function updateUserDevicesList() {
        const userDevicesList = document.getElementById('userDevicesList');
        
        if (currentUser && currentUser.devices && currentUser.devices.length > 0) {
            userDevicesList.textContent = currentUser.devices.join(', ');
        } else {
            userDevicesList.textContent = 'No devices assigned';
        }
    }

    async function addTestDevice() {
        const testDevice = {
            device_name: 'Test Device '+ Date.now(),
            device_type: 'test_type'
        };
        const res = await fetch('/api/device', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testDevice)
        });
        const data = await res.json();
        if (!data.insertedId) {
            alert('Add device failed');
            return null;
        }
        localStorage.setItem('lastDeviceId', data.insertedId);
        lastDeviceId = data.insertedId;
        alert('Added device ID: '+data.insertedId);
        
        // Add the new device to current user's device list if logged in
        if (currentUser && currentUser.username) {
            try {
                const response = await fetch('/api/user/devices/add', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        username: currentUser.username,
                        device_id: data.insertedId.toString()
                    })
                });
                
                const result = await response.json();
                if (response.ok && result.success) {
                    // Update current user data
                    currentUser.devices = result.devices;
                    localStorage.setItem('userData', JSON.stringify(currentUser));
                    console.log('Device added to user account:', data.insertedId);
                    updateUserDevicesList();
                    await loadDevices(); // Reload main device dropdown
                }
            } catch (error) {
                console.error('Error adding device to user:', error);
            }
        }
        
        await loadTestDeviceList();
        return data.insertedId;
    }

    async function addTestControl(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testControl = {
            device_id: deviceId,
            control_id: lastSensorId,
            control_type: 'button',
            control_name: 'Test Control',
            state: 'off'
        };
        const res = await fetch('/api/controls', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testControl)
        });
        const data = await res.json();
        if (!data.control_id) {
            alert('Add control failed');
            return null;
        }
        localStorage.setItem('lastControlId', data.control_id);
        lastControlId= data.control_id;
        alert('Added control ID: ' + data.control_id);
        return data.control_id;
    }

    async function addTestSensor(deviceId) {
        if (!deviceId) {
            alert('Please add or select a device first');
            return;
        }
        const testSensor = {
            device_id: deviceId,
            sensor_type: 'temperature',
            sensor_name: 'Test Sensor'
        };
        const res = await fetch('/api/sensors', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testSensor)
        });
        const data = await res.json();
        if (!data.sensor_id) {
            alert('Add sensor failed');
            return null;
        }
        localStorage.setItem('lastSensorId', data.sensor_id);
        lastSensorId= data.sensor_id;
        alert('Added sensor ID: ' + data.sensor_id);
        await loadTestDeviceList();
        return data.sensor_id;
    }

    async function addTestSensorData(sensorId) {
        if (!sensorId) {
            alert('Please add or select a sensor first');
            return;
        }
        const testData = {
            sensor_id: sensorId,
            timestamp: Math.floor(Date.now() / 1000),
            data: { temperature: (20 + Math.random() * 10).toFixed(2), humidity: (40 + Math.random() * 20).toFixed(2) }
        };
        const res = await fetch('/api/sensor_data', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(testData)
        });
        const data = await res.json();
        if (!data.data_id) {
            alert('Add sensor data failed');
            return null;
        }
        localStorage.setItem('lastSensorDataId', data.data_id);
        alert('Added sensor data ID: ' + data.data_id);
        return data.data_id;
    }

    async function addTestAll() {
        const deviceId = await addTestDevice();
        if (!deviceId) return;
        const controlId = await addTestControl(deviceId);
        const sensorId = await addTestSensor(deviceId);
        if (sensorId) {
            await addTestSensorData(sensorId);
        }
        alert('Add datas successfully!');
    }

    function saveSettingsToLocal() {
        localStorage.setItem('iot-dashboard-timeRange', selectedTimeRange);
        localStorage.setItem('iot-dashboard-chartType', selectedChartType);
        defaultTimeRangeSelect.value = selectedTimeRange;
        defaultChartTypeSelect.value = selectedChartType;
    }

    function loadSettings() {
        selectedTimeRange = localStorage.getItem('iot-dashboard-timeRange') || 'hour';
        selectedChartType = localStorage.getItem('iot-dashboard-chartType') || 'line';

    }




    async function checkNewMessages() {
        const resp = await fetch(`/api/messages?after=${lastMessageTimestamp}`);
        const messages = await resp.json();
        if (!messages.length) return;

        messages.sort((a, b) => a.created_at - b.created_at);

        for (const msg of messages) {
            lastMessageTimestamp = Math.max(lastMessageTimestamp, msg.created_at);
            if (msg.from_source.startsWith('web')) continue;
            updateWidgetState(msg.control_id, msg.state);
        }
    }

    function updateWidgetState(control_id, state) {
        const widget = widgets.find(w => w.control_id === control_id);
        if (widget) {
            widget.state = state;
            renderWidgets();
        }
    }

    function reloadTimeRangeBtn(){
        timeRangeButtons.querySelectorAll('button').forEach(b => b.classList.remove('active'));
        const activeBtn = timeRangeButtons.querySelector(`button[data-range="${selectedTimeRange}"]`);
        if (activeBtn) activeBtn.classList.add('active');
    }

    async function loadTestDeviceList() {
        const res = await fetch('/api/device?device_name=test&limit=100');
        const devices = await res.json();
        const testDeviceList = document.getElementById('testDeviceList');
        testDeviceList.innerHTML = '';
        if (!devices.length) {
            testDeviceList.innerHTML = '<span style="color:#e74c3c;">No test device found.</span>';
            document.getElementById('testSensorList').innerHTML = '';
            document.getElementById('lastDeviceInfo').textContent = 'No lastDeviceId';
            return;
        }
        devices.forEach((d, idx) => {
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'testDeviceRadio';
            radio.value = d.device_id;
            if (idx === 0) radio.checked = true;
            radio.addEventListener('change', () => {
                localStorage.setItem('lastDeviceId', d.device_id);
                loadTestSensorList(d.device_id);
                document.getElementById('lastDeviceInfo').textContent = `lastDeviceId: ${d.device_id}`;
            });
            testDeviceList.appendChild(radio);
            const label = document.createElement('label');
            label.textContent = `${d.device_name} (${d.device_id})`;
            label.style.marginRight = '15px';
            testDeviceList.appendChild(label);
        });
        const firstId = devices[0].device_id;
        localStorage.setItem('lastDeviceId', firstId);
        document.getElementById('lastDeviceInfo').textContent = `lastDeviceId: ${firstId}`;
        loadTestSensorList(firstId);
    }

    async function loadTestSensorList(deviceId) {
        if (!deviceId) {
            document.getElementById('testSensorList').innerHTML = '';
            return;
        }
        const res = await fetch(`/api/sensors?device_id=${deviceId}&limit=100`);
        const sensors = await res.json();
        const testSensorList = document.getElementById('testSensorList');
        testSensorList.innerHTML = '';
        if (!sensors.length) {
            testSensorList.innerHTML = '<span style="color:#e74c3c;">No sensor found.</span>';
            return;
        }
        sensors.forEach((s, idx) => {
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'testSensorRadio';
            radio.value = s.sensor_id;
            if (idx === 0) radio.checked = true;
            radio.addEventListener('change', () => {
                localStorage.setItem('lastSensorId', s.sensor_id);
            });
            testSensorList.appendChild(radio);
            const label = document.createElement('label');
            label.textContent = `${s.sensor_name} (${s.sensor_id})`;
            label.style.marginRight = '15px';
            testSensorList.appendChild(label);
        });
        localStorage.setItem('lastSensorId', sensors[0].sensor_id);
    }

    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            contents.forEach(c => c.classList.remove('active'));
            document.getElementById(tab.dataset.tab).classList.add('active');

            // Show lastDeviceId beside testDelete button when Test tab is active
            if (tab.dataset.tab === 'test') {
                loadTestDeviceList();
                updateUserDevicesList(); // Update user devices list when switching to Test tab
            }
        });
    });



    // Generate colors for pie/doughnut charts
    function pieColors(count) {
        const baseColors = [
            '#0e838f', '#8a2be2', '#ff7f50', '#ffdc34', '#0ecb81', '#c74e4e', '#bc7af9',
            '#f08a5d', '#f9ed69', '#3ec1d3', '#ffb6b9', '#283c63'
        ];
        return Array(count).fill(0).map((_, i) => baseColors[i % baseColors.length]);
    }
</script>
</body>
</html>
